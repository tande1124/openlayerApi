{"version":3,"sources":["webpack:///./shaded-relief.js"],"names":["const","elevation","url","crossOrigin","raster","sources","operationType","operation","inputs","data","pixelX","pixelY","x1","y0","y1","offset","z0","dzdx","dzdy","slope","aspect","scaled","elevationImage","width","height","elevationData","shadeData","Uint8ClampedArray","length","dp","resolution","maxX","maxY","pixel","twoPi","Math","PI","halfPi","sunEl","sunAz","cosSunEl","cos","sinSunEl","sin","vert","atan","sqrt","atan2","controls","target","layers","source","opacity","view","extent","center","minZoom","maxZoom","zoom","forEach","id","control","document","getElementById","output","addEventListener","innerText","value","changed","on","event","Number"],"mappings":"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","file":"shaded-relief.js","sourcesContent":["import Map from '../src/ol/Map.js';\r\nimport View from '../src/ol/View.js';\r\nimport {Image as ImageLayer, Tile as TileLayer} from '../src/ol/layer.js';\r\nimport {OSM, Raster, XYZ} from '../src/ol/source.js';\r\n\r\n/**\r\n * Generates a shaded relief image given elevation data.  Uses a 3x3\r\n * neighborhood for determining slope and aspect.\r\n * @param {Array<ImageData>} inputs Array of input images.\r\n * @param {Object} data Data added in the \"beforeoperations\" event.\r\n * @return {ImageData} Output image.\r\n */\r\nfunction shade(inputs, data) {\r\n  const elevationImage = inputs[0];\r\n  const width = elevationImage.width;\r\n  const height = elevationImage.height;\r\n  const elevationData = elevationImage.data;\r\n  const shadeData = new Uint8ClampedArray(elevationData.length);\r\n  const dp = data.resolution * 2;\r\n  const maxX = width - 1;\r\n  const maxY = height - 1;\r\n  const pixel = [0, 0, 0, 0];\r\n  const twoPi = 2 * Math.PI;\r\n  const halfPi = Math.PI / 2;\r\n  const sunEl = (Math.PI * data.sunEl) / 180;\r\n  const sunAz = (Math.PI * data.sunAz) / 180;\r\n  const cosSunEl = Math.cos(sunEl);\r\n  const sinSunEl = Math.sin(sunEl);\r\n  let pixelX,\r\n    pixelY,\r\n    x0,\r\n    x1,\r\n    y0,\r\n    y1,\r\n    offset,\r\n    z0,\r\n    z1,\r\n    dzdx,\r\n    dzdy,\r\n    slope,\r\n    aspect,\r\n    cosIncidence,\r\n    scaled;\r\n  for (pixelY = 0; pixelY <= maxY; ++pixelY) {\r\n    y0 = pixelY === 0 ? 0 : pixelY - 1;\r\n    y1 = pixelY === maxY ? maxY : pixelY + 1;\r\n    for (pixelX = 0; pixelX <= maxX; ++pixelX) {\r\n      x0 = pixelX === 0 ? 0 : pixelX - 1;\r\n      x1 = pixelX === maxX ? maxX : pixelX + 1;\r\n\r\n      // determine elevation for (x0, pixelY)\r\n      offset = (pixelY * width + x0) * 4;\r\n      pixel[0] = elevationData[offset];\r\n      pixel[1] = elevationData[offset + 1];\r\n      pixel[2] = elevationData[offset + 2];\r\n      pixel[3] = elevationData[offset + 3];\r\n      z0 = data.vert * (pixel[0] + pixel[1] * 2 + pixel[2] * 3);\r\n\r\n      // determine elevation for (x1, pixelY)\r\n      offset = (pixelY * width + x1) * 4;\r\n      pixel[0] = elevationData[offset];\r\n      pixel[1] = elevationData[offset + 1];\r\n      pixel[2] = elevationData[offset + 2];\r\n      pixel[3] = elevationData[offset + 3];\r\n      z1 = data.vert * (pixel[0] + pixel[1] * 2 + pixel[2] * 3);\r\n\r\n      dzdx = (z1 - z0) / dp;\r\n\r\n      // determine elevation for (pixelX, y0)\r\n      offset = (y0 * width + pixelX) * 4;\r\n      pixel[0] = elevationData[offset];\r\n      pixel[1] = elevationData[offset + 1];\r\n      pixel[2] = elevationData[offset + 2];\r\n      pixel[3] = elevationData[offset + 3];\r\n      z0 = data.vert * (pixel[0] + pixel[1] * 2 + pixel[2] * 3);\r\n\r\n      // determine elevation for (pixelX, y1)\r\n      offset = (y1 * width + pixelX) * 4;\r\n      pixel[0] = elevationData[offset];\r\n      pixel[1] = elevationData[offset + 1];\r\n      pixel[2] = elevationData[offset + 2];\r\n      pixel[3] = elevationData[offset + 3];\r\n      z1 = data.vert * (pixel[0] + pixel[1] * 2 + pixel[2] * 3);\r\n\r\n      dzdy = (z1 - z0) / dp;\r\n\r\n      slope = Math.atan(Math.sqrt(dzdx * dzdx + dzdy * dzdy));\r\n\r\n      aspect = Math.atan2(dzdy, -dzdx);\r\n      if (aspect < 0) {\r\n        aspect = halfPi - aspect;\r\n      } else if (aspect > halfPi) {\r\n        aspect = twoPi - aspect + halfPi;\r\n      } else {\r\n        aspect = halfPi - aspect;\r\n      }\r\n\r\n      cosIncidence =\r\n        sinSunEl * Math.cos(slope) +\r\n        cosSunEl * Math.sin(slope) * Math.cos(sunAz - aspect);\r\n\r\n      offset = (pixelY * width + pixelX) * 4;\r\n      scaled = 255 * cosIncidence;\r\n      shadeData[offset] = scaled;\r\n      shadeData[offset + 1] = scaled;\r\n      shadeData[offset + 2] = scaled;\r\n      shadeData[offset + 3] = elevationData[offset + 3];\r\n    }\r\n  }\r\n\r\n  return {data: shadeData, width: width, height: height};\r\n}\r\n\r\nconst elevation = new XYZ({\r\n  url: 'https://{a-d}.tiles.mapbox.com/v3/aj.sf-dem/{z}/{x}/{y}.png',\r\n  crossOrigin: 'anonymous',\r\n});\r\n\r\nconst raster = new Raster({\r\n  sources: [elevation],\r\n  operationType: 'image',\r\n  operation: shade,\r\n});\r\n\r\nconst map = new Map({\r\n  target: 'map',\r\n  layers: [\r\n    new TileLayer({\r\n      source: new OSM(),\r\n    }),\r\n    new ImageLayer({\r\n      opacity: 0.3,\r\n      source: raster,\r\n    }),\r\n  ],\r\n  view: new View({\r\n    extent: [-13675026, 4439648, -13580856, 4580292],\r\n    center: [-13615645, 4497969],\r\n    minZoom: 10,\r\n    maxZoom: 16,\r\n    zoom: 13,\r\n  }),\r\n});\r\n\r\nconst controlIds = ['vert', 'sunEl', 'sunAz'];\r\nconst controls = {};\r\ncontrolIds.forEach(function (id) {\r\n  const control = document.getElementById(id);\r\n  const output = document.getElementById(id + 'Out');\r\n  control.addEventListener('input', function () {\r\n    output.innerText = control.value;\r\n    raster.changed();\r\n  });\r\n  output.innerText = control.value;\r\n  controls[id] = control;\r\n});\r\n\r\nraster.on('beforeoperations', function (event) {\r\n  // the event.data object will be passed to operations\r\n  const data = event.data;\r\n  data.resolution = event.resolution;\r\n  for (const id in controls) {\r\n    data[id] = Number(controls[id].value);\r\n  }\r\n});\r\n"],"sourceRoot":""}