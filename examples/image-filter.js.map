{"version":3,"sources":["webpack:///./image-filter.js"],"names":["imagery","source","attributions","url","maxZoom","crossOrigin","map","layers","target","view","center","zoom","kernels","none","sharpen","sharpenless","blur","shadow","emboss","edge","normalize","kernel","const","i","len","length","normal","Array","sum","normalized","select","document","getElementById","selectedKernel","value","onchange","render","on","event","context","canvas","width","height","size","Math","sqrt","half","floor","inputData","getImageData","data","output","createImageData","outputData","pixelY","pixelsAbove","pixelX","let","r","g","b","a","kernelY","kernelX","weight","inputIndex","min","max","outputIndex","putImageData","convolve"],"mappings":"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","file":"image-filter.js","sourcesContent":["import Map from '../src/ol/Map.js';\r\nimport TileLayer from '../src/ol/layer/Tile.js';\r\nimport View from '../src/ol/View.js';\r\nimport XYZ from '../src/ol/source/XYZ.js';\r\nimport {fromLonLat} from '../src/ol/proj.js';\r\n\r\nconst key = 'get_your_own_D6rA4zTHduk6KOKTXzGB';\r\nconst attributions =\r\n  '<a href=\"https://www.maptiler.com/copyright/\" target=\"_blank\">&copy; MapTiler</a> ' +\r\n  '<a href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\">&copy; OpenStreetMap contributors</a>';\r\n\r\nconst imagery = new TileLayer({\r\n  source: new XYZ({\r\n    attributions: attributions,\r\n    url: 'https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=' + key,\r\n    maxZoom: 20,\r\n    crossOrigin: '',\r\n  }),\r\n});\r\n\r\nconst map = new Map({\r\n  layers: [imagery],\r\n  target: 'map',\r\n  view: new View({\r\n    center: fromLonLat([-120, 50]),\r\n    zoom: 6,\r\n  }),\r\n});\r\n\r\nconst kernels = {\r\n  none: [0, 0, 0, 0, 1, 0, 0, 0, 0],\r\n  sharpen: [0, -1, 0, -1, 5, -1, 0, -1, 0],\r\n  sharpenless: [0, -1, 0, -1, 10, -1, 0, -1, 0],\r\n  blur: [1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n  shadow: [1, 2, 1, 0, 1, 0, -1, -2, -1],\r\n  emboss: [-2, 1, 0, -1, 1, 1, 0, 1, 2],\r\n  edge: [0, 1, 0, 1, -4, 1, 0, 1, 0],\r\n};\r\n\r\nfunction normalize(kernel) {\r\n  const len = kernel.length;\r\n  const normal = new Array(len);\r\n  let i,\r\n    sum = 0;\r\n  for (i = 0; i < len; ++i) {\r\n    sum += kernel[i];\r\n  }\r\n  if (sum <= 0) {\r\n    normal.normalized = false;\r\n    sum = 1;\r\n  } else {\r\n    normal.normalized = true;\r\n  }\r\n  for (i = 0; i < len; ++i) {\r\n    normal[i] = kernel[i] / sum;\r\n  }\r\n  return normal;\r\n}\r\n\r\nconst select = document.getElementById('kernel');\r\nlet selectedKernel = normalize(kernels[select.value]);\r\n\r\n/**\r\n * Update the kernel and re-render on change.\r\n */\r\nselect.onchange = function () {\r\n  selectedKernel = normalize(kernels[select.value]);\r\n  map.render();\r\n};\r\n\r\n/**\r\n * Apply a filter on \"postrender\" events.\r\n */\r\nimagery.on('postrender', function (event) {\r\n  convolve(event.context, selectedKernel);\r\n});\r\n\r\n/**\r\n * Apply a convolution kernel to canvas.  This works for any size kernel, but\r\n * performance starts degrading above 3 x 3.\r\n * @param {CanvasRenderingContext2D} context Canvas 2d context.\r\n * @param {Array<number>} kernel Kernel.\r\n */\r\nfunction convolve(context, kernel) {\r\n  const canvas = context.canvas;\r\n  const width = canvas.width;\r\n  const height = canvas.height;\r\n\r\n  const size = Math.sqrt(kernel.length);\r\n  const half = Math.floor(size / 2);\r\n\r\n  const inputData = context.getImageData(0, 0, width, height).data;\r\n\r\n  const output = context.createImageData(width, height);\r\n  const outputData = output.data;\r\n\r\n  for (let pixelY = 0; pixelY < height; ++pixelY) {\r\n    const pixelsAbove = pixelY * width;\r\n    for (let pixelX = 0; pixelX < width; ++pixelX) {\r\n      let r = 0,\r\n        g = 0,\r\n        b = 0,\r\n        a = 0;\r\n      for (let kernelY = 0; kernelY < size; ++kernelY) {\r\n        for (let kernelX = 0; kernelX < size; ++kernelX) {\r\n          const weight = kernel[kernelY * size + kernelX];\r\n          const neighborY = Math.min(\r\n            height - 1,\r\n            Math.max(0, pixelY + kernelY - half)\r\n          );\r\n          const neighborX = Math.min(\r\n            width - 1,\r\n            Math.max(0, pixelX + kernelX - half)\r\n          );\r\n          const inputIndex = (neighborY * width + neighborX) * 4;\r\n          r += inputData[inputIndex] * weight;\r\n          g += inputData[inputIndex + 1] * weight;\r\n          b += inputData[inputIndex + 2] * weight;\r\n          a += inputData[inputIndex + 3] * weight;\r\n        }\r\n      }\r\n      const outputIndex = (pixelsAbove + pixelX) * 4;\r\n      outputData[outputIndex] = r;\r\n      outputData[outputIndex + 1] = g;\r\n      outputData[outputIndex + 2] = b;\r\n      outputData[outputIndex + 3] = kernel.normalized ? a : 255;\r\n    }\r\n  }\r\n  context.putImageData(output, 0, 0);\r\n}\r\n"],"sourceRoot":""}