{"version":3,"sources":["webpack:///../src/ol/layer/Heatmap.js","webpack:///./heatmap-earthquakes.js"],"names":["Property","DEFAULT_GRADIENT","opt_options","const","options","baseOptions","gradient","radius","blur","weight","super","this","gradient_","addEventListener","handleGradientChanged_","setGradient","setBlur","undefined","setRadius","weightFunction_","feature","get","setRenderOrder","getBlur","getGradient","getRadius","colors","width","height","context","createLinearGradient","step","length","i","ii","addColorStop","fillStyle","fillRect","canvas","createGradient","set","createRenderer","className","getClassName","attributes","name","callback","bind","vertexShader","fragmentShader","hitVertexShader","hitFragmentShader","uniforms","u_size","u_blurSlope","Math","max","postProcesses","u_gradientTexture","renderDeclutter","document","getElementById","vector","source","Vector","url","format","KML","extractStyles","parseInt","value","parseFloat","substr","raster","Tile","Stamen","layer","Map","layers","target","view","View","center","zoom","blurHandler","radiusHandler"],"mappings":"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","file":"heatmap-earthquakes.js","sourcesContent":["/**\r\n * @module ol/layer/Heatmap\r\n */\r\nimport VectorLayer from './Vector.js';\r\nimport WebGLPointsLayerRenderer from '../renderer/webgl/PointsLayer.js';\r\nimport {assign} from '../obj.js';\r\nimport {clamp} from '../math.js';\r\nimport {createCanvasContext2D} from '../dom.js';\r\nimport {getChangeEventType} from '../Object.js';\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\r\n * @property {number} [opacity=1] Opacity (0, 1).\r\n * @property {boolean} [visible=true] Visibility.\r\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\r\n * rendered outside of this extent.\r\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\r\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\r\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\r\n * method was used.\r\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\r\n * visible.\r\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\r\n * be visible.\r\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\r\n * visible.\r\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\r\n * be visible.\r\n * @property {Array<string>} [gradient=['#00f', '#0ff', '#0f0', '#ff0', '#f00']] The color gradient\r\n * of the heatmap, specified as an array of CSS color strings.\r\n * @property {number} [radius=8] Radius size in pixels.\r\n * @property {number} [blur=15] Blur size in pixels.\r\n * @property {string|function(import(\"../Feature.js\").default):number} [weight='weight'] The feature\r\n * attribute to use for the weight or a function that returns a weight from a feature. Weight values\r\n * should range from 0 to 1 (and values outside will be clamped to that range).\r\n * @property {import(\"../source/Vector.js\").default} [source] Source.\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n * @private\r\n */\r\nconst Property = {\r\n  BLUR: 'blur',\r\n  GRADIENT: 'gradient',\r\n  RADIUS: 'radius',\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Array<string>}\r\n */\r\nconst DEFAULT_GRADIENT = ['#00f', '#0ff', '#0f0', '#ff0', '#f00'];\r\n\r\n/**\r\n * @classdesc\r\n * Layer for rendering vector data as a heatmap.\r\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\r\n * property on the layer object; for example, setting `title: 'My Title'` in the\r\n * options means that `title` is observable, and has get/set accessors.\r\n *\r\n * @fires import(\"../render/Event.js\").RenderEvent\r\n * @api\r\n */\r\nclass Heatmap extends VectorLayer {\r\n  /**\r\n   * @param {Options=} opt_options Options.\r\n   */\r\n  constructor(opt_options) {\r\n    const options = opt_options ? opt_options : {};\r\n\r\n    const baseOptions = assign({}, options);\r\n\r\n    delete baseOptions.gradient;\r\n    delete baseOptions.radius;\r\n    delete baseOptions.blur;\r\n    delete baseOptions.weight;\r\n    super(baseOptions);\r\n\r\n    /**\r\n     * @private\r\n     * @type {HTMLCanvasElement}\r\n     */\r\n    this.gradient_ = null;\r\n\r\n    this.addEventListener(\r\n      getChangeEventType(Property.GRADIENT),\r\n      this.handleGradientChanged_\r\n    );\r\n\r\n    this.setGradient(options.gradient ? options.gradient : DEFAULT_GRADIENT);\r\n\r\n    this.setBlur(options.blur !== undefined ? options.blur : 15);\r\n\r\n    this.setRadius(options.radius !== undefined ? options.radius : 8);\r\n\r\n    const weight = options.weight ? options.weight : 'weight';\r\n    if (typeof weight === 'string') {\r\n      this.weightFunction_ = function (feature) {\r\n        return feature.get(weight);\r\n      };\r\n    } else {\r\n      this.weightFunction_ = weight;\r\n    }\r\n\r\n    // For performance reasons, don't sort the features before rendering.\r\n    // The render order is not relevant for a heatmap representation.\r\n    this.setRenderOrder(null);\r\n  }\r\n\r\n  /**\r\n   * Return the blur size in pixels.\r\n   * @return {number} Blur size in pixels.\r\n   * @api\r\n   * @observable\r\n   */\r\n  getBlur() {\r\n    return /** @type {number} */ (this.get(Property.BLUR));\r\n  }\r\n\r\n  /**\r\n   * Return the gradient colors as array of strings.\r\n   * @return {Array<string>} Colors.\r\n   * @api\r\n   * @observable\r\n   */\r\n  getGradient() {\r\n    return /** @type {Array<string>} */ (this.get(Property.GRADIENT));\r\n  }\r\n\r\n  /**\r\n   * Return the size of the radius in pixels.\r\n   * @return {number} Radius size in pixel.\r\n   * @api\r\n   * @observable\r\n   */\r\n  getRadius() {\r\n    return /** @type {number} */ (this.get(Property.RADIUS));\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  handleGradientChanged_() {\r\n    this.gradient_ = createGradient(this.getGradient());\r\n  }\r\n\r\n  /**\r\n   * Set the blur size in pixels.\r\n   * @param {number} blur Blur size in pixels.\r\n   * @api\r\n   * @observable\r\n   */\r\n  setBlur(blur) {\r\n    this.set(Property.BLUR, blur);\r\n  }\r\n\r\n  /**\r\n   * Set the gradient colors as array of strings.\r\n   * @param {Array<string>} colors Gradient.\r\n   * @api\r\n   * @observable\r\n   */\r\n  setGradient(colors) {\r\n    this.set(Property.GRADIENT, colors);\r\n  }\r\n\r\n  /**\r\n   * Set the size of the radius in pixels.\r\n   * @param {number} radius Radius size in pixel.\r\n   * @api\r\n   * @observable\r\n   */\r\n  setRadius(radius) {\r\n    this.set(Property.RADIUS, radius);\r\n  }\r\n\r\n  /**\r\n   * Create a renderer for this layer.\r\n   * @return {WebGLPointsLayerRenderer} A layer renderer.\r\n   */\r\n  createRenderer() {\r\n    return new WebGLPointsLayerRenderer(this, {\r\n      className: this.getClassName(),\r\n      attributes: [\r\n        {\r\n          name: 'weight',\r\n          callback: function (feature) {\r\n            const weight = this.weightFunction_(feature);\r\n            return weight !== undefined ? clamp(weight, 0, 1) : 1;\r\n          }.bind(this),\r\n        },\r\n      ],\r\n      vertexShader: `\r\n        precision mediump float;\r\n        uniform mat4 u_projectionMatrix;\r\n        uniform mat4 u_offsetScaleMatrix;\r\n        uniform float u_size;\r\n        attribute vec2 a_position;\r\n        attribute float a_index;\r\n        attribute float a_weight;\r\n\r\n        varying vec2 v_texCoord;\r\n        varying float v_weight;\r\n\r\n        void main(void) {\r\n          mat4 offsetMatrix = u_offsetScaleMatrix;\r\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\r\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\r\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\r\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\r\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\r\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\r\n          v_texCoord = vec2(u, v);\r\n          v_weight = a_weight;\r\n        }`,\r\n      fragmentShader: `\r\n        precision mediump float;\r\n        uniform float u_blurSlope;\r\n\r\n        varying vec2 v_texCoord;\r\n        varying float v_weight;\r\n\r\n        void main(void) {\r\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\r\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\r\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\r\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\r\n          gl_FragColor = vec4(alpha, alpha, alpha, alpha);\r\n        }`,\r\n      hitVertexShader: `\r\n        precision mediump float;\r\n        uniform mat4 u_projectionMatrix;\r\n        uniform mat4 u_offsetScaleMatrix;\r\n        uniform float u_size;\r\n        attribute vec2 a_position;\r\n        attribute float a_index;\r\n        attribute float a_weight;\r\n        attribute vec4 a_hitColor;\r\n\r\n        varying vec2 v_texCoord;\r\n        varying float v_weight;\r\n        varying vec4 v_hitColor;\r\n\r\n        void main(void) {\r\n          mat4 offsetMatrix = u_offsetScaleMatrix;\r\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\r\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\r\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\r\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\r\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\r\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\r\n          v_texCoord = vec2(u, v);\r\n          v_hitColor = a_hitColor;\r\n          v_weight = a_weight;\r\n        }`,\r\n      hitFragmentShader: `\r\n        precision mediump float;\r\n        uniform float u_blurSlope;\r\n\r\n        varying vec2 v_texCoord;\r\n        varying float v_weight;\r\n        varying vec4 v_hitColor;\r\n\r\n        void main(void) {\r\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\r\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\r\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\r\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\r\n          if (alpha < 0.05) {\r\n            discard;\r\n          }\r\n\r\n          gl_FragColor = v_hitColor;\r\n        }`,\r\n      uniforms: {\r\n        u_size: function () {\r\n          return (this.get(Property.RADIUS) + this.get(Property.BLUR)) * 2;\r\n        }.bind(this),\r\n        u_blurSlope: function () {\r\n          return (\r\n            this.get(Property.RADIUS) / Math.max(1, this.get(Property.BLUR))\r\n          );\r\n        }.bind(this),\r\n      },\r\n      postProcesses: [\r\n        {\r\n          fragmentShader: `\r\n            precision mediump float;\r\n\r\n            uniform sampler2D u_image;\r\n            uniform sampler2D u_gradientTexture;\r\n\r\n            varying vec2 v_texCoord;\r\n\r\n            void main() {\r\n              vec4 color = texture2D(u_image, v_texCoord);\r\n              gl_FragColor.a = color.a;\r\n              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;\r\n              gl_FragColor.rgb *= gl_FragColor.a;\r\n            }`,\r\n          uniforms: {\r\n            u_gradientTexture: function () {\r\n              return this.gradient_;\r\n            }.bind(this),\r\n          },\r\n        },\r\n      ],\r\n    });\r\n  }\r\n\r\n  renderDeclutter() {}\r\n}\r\n\r\n/**\r\n * @param {Array<string>} colors A list of colored.\r\n * @return {HTMLCanvasElement} canvas with gradient texture.\r\n */\r\nfunction createGradient(colors) {\r\n  const width = 1;\r\n  const height = 256;\r\n  const context = createCanvasContext2D(width, height);\r\n\r\n  const gradient = context.createLinearGradient(0, 0, width, height);\r\n  const step = 1 / (colors.length - 1);\r\n  for (let i = 0, ii = colors.length; i < ii; ++i) {\r\n    gradient.addColorStop(i * step, colors[i]);\r\n  }\r\n\r\n  context.fillStyle = gradient;\r\n  context.fillRect(0, 0, width, height);\r\n\r\n  return context.canvas;\r\n}\r\n\r\nexport default Heatmap;\r\n","import KML from '../src/ol/format/KML.js';\r\nimport Map from '../src/ol/Map.js';\r\nimport Stamen from '../src/ol/source/Stamen.js';\r\nimport VectorSource from '../src/ol/source/Vector.js';\r\nimport View from '../src/ol/View.js';\r\nimport {Heatmap as HeatmapLayer, Tile as TileLayer} from '../src/ol/layer.js';\r\n\r\nconst blur = document.getElementById('blur');\r\nconst radius = document.getElementById('radius');\r\n\r\nconst vector = new HeatmapLayer({\r\n  source: new VectorSource({\r\n    url: 'data/kml/2012_Earthquakes_Mag5.kml',\r\n    format: new KML({\r\n      extractStyles: false,\r\n    }),\r\n  }),\r\n  blur: parseInt(blur.value, 10),\r\n  radius: parseInt(radius.value, 10),\r\n  weight: function (feature) {\r\n    // 2012_Earthquakes_Mag5.kml stores the magnitude of each earthquake in a\r\n    // standards-violating <magnitude> tag in each Placemark.  We extract it from\r\n    // the Placemark's name instead.\r\n    const name = feature.get('name');\r\n    const magnitude = parseFloat(name.substr(2));\r\n    return magnitude - 5;\r\n  },\r\n});\r\n\r\nconst raster = new TileLayer({\r\n  source: new Stamen({\r\n    layer: 'toner',\r\n  }),\r\n});\r\n\r\nnew Map({\r\n  layers: [raster, vector],\r\n  target: 'map',\r\n  view: new View({\r\n    center: [0, 0],\r\n    zoom: 2,\r\n  }),\r\n});\r\n\r\nconst blurHandler = function () {\r\n  vector.setBlur(parseInt(blur.value, 10));\r\n};\r\nblur.addEventListener('input', blurHandler);\r\nblur.addEventListener('change', blurHandler);\r\n\r\nconst radiusHandler = function () {\r\n  vector.setRadius(parseInt(radius.value, 10));\r\n};\r\nradius.addEventListener('input', radiusHandler);\r\nradius.addEventListener('change', radiusHandler);\r\n"],"sourceRoot":""}