{"version":3,"sources":["webpack:///../src/ol/interaction/Translate.js","webpack:///./translate-features.js"],"names":["TranslateEventType","TranslateEvent","type","features","coordinate","startCoordinate","mapBrowserEvent","super","this","Translate","opt_options","const","layerFilter","options","lastCoordinate_","startCoordinate_","features_","undefined","layers","layer","layerFilter_","filter_","filter","hitTolerance_","hitTolerance","lastFeature_","addEventListener","ACTIVE","handleActiveChanged_","handleDownEvent","event","featuresAtPixel_","pixel","map","handleMoveEvent","dispatchEvent","handleUpEvent","handleDragEvent","newCoordinate","deltaX","deltaY","forEach","feature","geom","getGeometry","translate","setGeometry","elem","getViewport","classList","remove","add","forEachFeatureAtPixel","getArray","bind","getHitTolerance","setHitTolerance","setMap","oldMap","getMap","updateState_","let","active","getActive","raster","source","vector","url","format","select","getFeatures","interactions","extend","target","view","center","zoom"],"mappings":"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","file":"translate-features.js","sourcesContent":["/**\r\n * @module ol/interaction/Translate\r\n */\r\nimport Collection from '../Collection.js';\r\nimport Event from '../events/Event.js';\r\nimport InteractionProperty from './Property.js';\r\nimport PointerInteraction from './Pointer.js';\r\nimport {TRUE} from '../functions.js';\r\nimport {getChangeEventType} from '../Object.js';\r\nimport {includes} from '../array.js';\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nconst TranslateEventType = {\r\n  /**\r\n   * Triggered upon feature translation start.\r\n   * @event TranslateEvent#translatestart\r\n   * @api\r\n   */\r\n  TRANSLATESTART: 'translatestart',\r\n  /**\r\n   * Triggered upon feature translation.\r\n   * @event TranslateEvent#translating\r\n   * @api\r\n   */\r\n  TRANSLATING: 'translating',\r\n  /**\r\n   * Triggered upon feature translation end.\r\n   * @event TranslateEvent#translateend\r\n   * @api\r\n   */\r\n  TRANSLATEEND: 'translateend',\r\n};\r\n\r\n/**\r\n * A function that takes an {@link module:ol/Feature} or\r\n * {@link module:ol/render/Feature} and an\r\n * {@link module:ol/layer/Layer} and returns `true` if the feature may be\r\n * translated or `false` otherwise.\r\n * @typedef {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default):boolean} FilterFunction\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {Collection<import(\"../Feature.js\").default>} [features] Only features contained in this collection will be able to be translated. If\r\n * not specified, all features on the map will be able to be translated.\r\n * @property {Array<import(\"../layer/Layer.js\").default>|function(import(\"../layer/Layer.js\").default): boolean} [layers] A list of layers from which features should be\r\n * translated. Alternatively, a filter function can be provided. The\r\n * function will be called for each layer in the map and should return\r\n * `true` for layers that you want to be translatable. If the option is\r\n * absent, all visible layers will be considered translatable.\r\n * @property {FilterFunction} [filter] A function\r\n * that takes an {@link module:ol/Feature} and an\r\n * {@link module:ol/layer/Layer} and returns `true` if the feature may be\r\n * translated or `false` otherwise.\r\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position\r\n * will be checked for features.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Events emitted by {@link module:ol/interaction/Translate~Translate} instances\r\n * are instances of this type.\r\n */\r\nexport class TranslateEvent extends Event {\r\n  /**\r\n   * @param {TranslateEventType} type Type.\r\n   * @param {Collection<import(\"../Feature.js\").default>} features The features translated.\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate The event coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} startCoordinate The original coordinates before.translation started\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n   */\r\n  constructor(type, features, coordinate, startCoordinate, mapBrowserEvent) {\r\n    super(type);\r\n\r\n    /**\r\n     * The features being translated.\r\n     * @type {Collection<import(\"../Feature.js\").default>}\r\n     * @api\r\n     */\r\n    this.features = features;\r\n\r\n    /**\r\n     * The coordinate of the drag event.\r\n     * @const\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     * @api\r\n     */\r\n    this.coordinate = coordinate;\r\n\r\n    /**\r\n     * The coordinate of the start position before translation started.\r\n     * @const\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     * @api\r\n     */\r\n    this.startCoordinate = startCoordinate;\r\n\r\n    /**\r\n     * Associated {@link module:ol/MapBrowserEvent}.\r\n     * @type {import(\"../MapBrowserEvent.js\").default}\r\n     * @api\r\n     */\r\n    this.mapBrowserEvent = mapBrowserEvent;\r\n  }\r\n}\r\n\r\n/**\r\n * @classdesc\r\n * Interaction for translating (moving) features.\r\n *\r\n * @fires TranslateEvent\r\n * @api\r\n */\r\nclass Translate extends PointerInteraction {\r\n  /**\r\n   * @param {Options=} opt_options Options.\r\n   */\r\n  constructor(opt_options) {\r\n    const options = opt_options ? opt_options : {};\r\n\r\n    super(/** @type {import(\"./Pointer.js\").Options} */ (options));\r\n\r\n    /**\r\n     * The last position we translated to.\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     * @private\r\n     */\r\n    this.lastCoordinate_ = null;\r\n\r\n    /**\r\n     * The start position before translation started.\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     * @private\r\n     */\r\n    this.startCoordinate_ = null;\r\n\r\n    /**\r\n     * @type {Collection<import(\"../Feature.js\").default>}\r\n     * @private\r\n     */\r\n    this.features_ = options.features !== undefined ? options.features : null;\r\n\r\n    /** @type {function(import(\"../layer/Layer.js\").default): boolean} */\r\n    let layerFilter;\r\n    if (options.layers) {\r\n      if (typeof options.layers === 'function') {\r\n        layerFilter = options.layers;\r\n      } else {\r\n        const layers = options.layers;\r\n        layerFilter = function (layer) {\r\n          return includes(layers, layer);\r\n        };\r\n      }\r\n    } else {\r\n      layerFilter = TRUE;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @type {function(import(\"../layer/Layer.js\").default): boolean}\r\n     */\r\n    this.layerFilter_ = layerFilter;\r\n\r\n    /**\r\n     * @private\r\n     * @type {FilterFunction}\r\n     */\r\n    this.filter_ = options.filter ? options.filter : TRUE;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\r\n\r\n    /**\r\n     * @type {import(\"../Feature.js\").default}\r\n     * @private\r\n     */\r\n    this.lastFeature_ = null;\r\n\r\n    this.addEventListener(\r\n      getChangeEventType(InteractionProperty.ACTIVE),\r\n      this.handleActiveChanged_\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Handle pointer down events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   * @return {boolean} If the event was consumed.\r\n   */\r\n  handleDownEvent(event) {\r\n    this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);\r\n    if (!this.lastCoordinate_ && this.lastFeature_) {\r\n      this.startCoordinate_ = event.coordinate;\r\n      this.lastCoordinate_ = event.coordinate;\r\n      this.handleMoveEvent(event);\r\n\r\n      const features = this.features_ || new Collection([this.lastFeature_]);\r\n\r\n      this.dispatchEvent(\r\n        new TranslateEvent(\r\n          TranslateEventType.TRANSLATESTART,\r\n          features,\r\n          event.coordinate,\r\n          this.startCoordinate_,\r\n          event\r\n        )\r\n      );\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer up events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   * @return {boolean} If the event was consumed.\r\n   */\r\n  handleUpEvent(event) {\r\n    if (this.lastCoordinate_) {\r\n      this.lastCoordinate_ = null;\r\n      this.handleMoveEvent(event);\r\n\r\n      const features = this.features_ || new Collection([this.lastFeature_]);\r\n\r\n      this.dispatchEvent(\r\n        new TranslateEvent(\r\n          TranslateEventType.TRANSLATEEND,\r\n          features,\r\n          event.coordinate,\r\n          this.startCoordinate_,\r\n          event\r\n        )\r\n      );\r\n      // cleanup\r\n      this.startCoordinate_ = null;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Handle pointer drag events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   */\r\n  handleDragEvent(event) {\r\n    if (this.lastCoordinate_) {\r\n      const newCoordinate = event.coordinate;\r\n      const deltaX = newCoordinate[0] - this.lastCoordinate_[0];\r\n      const deltaY = newCoordinate[1] - this.lastCoordinate_[1];\r\n\r\n      const features = this.features_ || new Collection([this.lastFeature_]);\r\n\r\n      features.forEach(function (feature) {\r\n        const geom = feature.getGeometry();\r\n        geom.translate(deltaX, deltaY);\r\n        feature.setGeometry(geom);\r\n      });\r\n\r\n      this.lastCoordinate_ = newCoordinate;\r\n\r\n      this.dispatchEvent(\r\n        new TranslateEvent(\r\n          TranslateEventType.TRANSLATING,\r\n          features,\r\n          newCoordinate,\r\n          this.startCoordinate_,\r\n          event\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle pointer move events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   */\r\n  handleMoveEvent(event) {\r\n    const elem = event.map.getViewport();\r\n\r\n    // Change the cursor to grab/grabbing if hovering any of the features managed\r\n    // by the interaction\r\n    if (this.featuresAtPixel_(event.pixel, event.map)) {\r\n      elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');\r\n      elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');\r\n    } else {\r\n      elem.classList.remove('ol-grab', 'ol-grabbing');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Tests to see if the given coordinates intersects any of our selected\r\n   * features.\r\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel coordinate to test for intersection.\r\n   * @param {import(\"../PluggableMap.js\").default} map Map to test the intersection on.\r\n   * @return {import(\"../Feature.js\").default} Returns the feature found at the specified pixel\r\n   * coordinates.\r\n   * @private\r\n   */\r\n  featuresAtPixel_(pixel, map) {\r\n    return map.forEachFeatureAtPixel(\r\n      pixel,\r\n      function (feature, layer) {\r\n        if (this.filter_(feature, layer)) {\r\n          if (!this.features_ || includes(this.features_.getArray(), feature)) {\r\n            return feature;\r\n          }\r\n        }\r\n      }.bind(this),\r\n      {\r\n        layerFilter: this.layerFilter_,\r\n        hitTolerance: this.hitTolerance_,\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns the Hit-detection tolerance.\r\n   * @returns {number} Hit tolerance in pixels.\r\n   * @api\r\n   */\r\n  getHitTolerance() {\r\n    return this.hitTolerance_;\r\n  }\r\n\r\n  /**\r\n   * Hit-detection tolerance. Pixels inside the radius around the given position\r\n   * will be checked for features.\r\n   * @param {number} hitTolerance Hit tolerance in pixels.\r\n   * @api\r\n   */\r\n  setHitTolerance(hitTolerance) {\r\n    this.hitTolerance_ = hitTolerance;\r\n  }\r\n\r\n  /**\r\n   * Remove the interaction from its current map and attach it to the new map.\r\n   * Subclasses may set up event handlers to get notified about changes to\r\n   * the map here.\r\n   * @param {import(\"../PluggableMap.js\").default} map Map.\r\n   */\r\n  setMap(map) {\r\n    const oldMap = this.getMap();\r\n    super.setMap(map);\r\n    this.updateState_(oldMap);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  handleActiveChanged_() {\r\n    this.updateState_(null);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../PluggableMap.js\").default} oldMap Old map.\r\n   * @private\r\n   */\r\n  updateState_(oldMap) {\r\n    let map = this.getMap();\r\n    const active = this.getActive();\r\n    if (!map || !active) {\r\n      map = map || oldMap;\r\n      if (map) {\r\n        const elem = map.getViewport();\r\n        elem.classList.remove('ol-grab', 'ol-grabbing');\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default Translate;\r\n","import GeoJSON from '../src/ol/format/GeoJSON.js';\r\nimport Map from '../src/ol/Map.js';\r\nimport OSM from '../src/ol/source/OSM.js';\r\nimport VectorSource from '../src/ol/source/Vector.js';\r\nimport View from '../src/ol/View.js';\r\nimport {\r\n  Select,\r\n  Translate,\r\n  defaults as defaultInteractions,\r\n} from '../src/ol/interaction.js';\r\nimport {Tile as TileLayer, Vector as VectorLayer} from '../src/ol/layer.js';\r\n\r\nconst raster = new TileLayer({\r\n  source: new OSM(),\r\n});\r\n\r\nconst vector = new VectorLayer({\r\n  source: new VectorSource({\r\n    url: 'data/geojson/countries.geojson',\r\n    format: new GeoJSON(),\r\n  }),\r\n});\r\n\r\nconst select = new Select();\r\n\r\nconst translate = new Translate({\r\n  features: select.getFeatures(),\r\n});\r\n\r\nconst map = new Map({\r\n  interactions: defaultInteractions().extend([select, translate]),\r\n  layers: [raster, vector],\r\n  target: 'map',\r\n  view: new View({\r\n    center: [0, 0],\r\n    zoom: 2,\r\n  }),\r\n});\r\n"],"sourceRoot":""}