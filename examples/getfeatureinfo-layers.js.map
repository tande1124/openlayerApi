{"version":3,"sources":["webpack:///../src/ol/format/WMSGetFeatureInfo.js","webpack:///./getfeatureinfo-layers.js"],"names":["opt_options","super","const","options","this","featureNS_","gmlFormat_","GML2","layers_","layers","getLayers","setLayers","readFeatures_","node","objectStack","setAttribute","localName","features","childNodes","length","let","i","ii","layer","nodeType","Node","ELEMENT_NODE","layerElement","context","layerName","replace","featureType","parsers","readFeatureElement","parsersNS","layerFeatures","gmlFeatures","FEATURE_COLLECTION_PARSERS","readFeaturesFromNode","getReadOptions","fetch","then","response","text","allFeatures","readFeatures","document","getElementById","innerText","toString","hotelFeatures","restaurantFeatures"],"mappings":"+IAqKe,EApI2B,YAIxC,WAAYA,GACVC,OAAM,MAENC,IAAMC,EAAUH,GAA4B,GAM5CI,KAAKC,WAAa,yCAMlBD,KAAKE,WAAa,IAAIC,EAAA,EAMtBH,KAAKI,QAAUL,EAAQM,OAASN,EAAQM,OAAS,K,8FAMnD,EAAF,UAAEC,UAAA,WACE,OAAON,KAAKI,SAMd,EAAF,UAAEG,UAAA,SAAUF,GACRL,KAAKI,QAAUC,GASjB,EAAF,UAAEG,cAAA,SAAcC,EAAMC,GAClBD,EAAKE,aAAa,eAAgBX,KAAKC,YACvCH,IAAMc,EAAYH,EAAKG,UAEnBC,EAAW,GACf,GAA+B,IAA3BJ,EAAKK,WAAWC,OAClB,OAAOF,EAET,GAAiB,eAAbD,EACF,IAAKI,IAAIC,EAAI,EAAGC,EAAKT,EAAKK,WAAWC,OAAQE,EAAIC,EAAID,IAAK,CACxDnB,IAAMqB,EAAQV,EAAKK,WAAWG,GAC9B,GAAIE,EAAMC,WAAaC,KAAKC,aAA5B,CAIAxB,IAAMyB,EAAsC,EACtCC,EAAUd,EAAY,GAGtBe,EAAYF,EAAaX,UAAUc,QA5EzB,SA4E2C,IAE3D,IAAI1B,KAAKI,SAAY,YAASJ,KAAKI,QAASqB,GAA5C,CAIA3B,IAAM6B,EAAcF,EAxFF,WA0FlBD,EAAqB,YAAIG,EACzBH,EAAmB,UAAIxB,KAAKC,WAG5BH,IAAM8B,EAAU,GAChBA,EAAQD,GAAe,YACrB3B,KAAKE,WAAW2B,mBAChB7B,KAAKE,YAEPJ,IAAMgC,EAAY,YAChB,CAACN,EAAmB,UAAG,MACvBI,GAEFL,EAAaZ,aAAa,eAAgBX,KAAKC,YAC/CH,IAAMiC,EAAgB,YACpB,GAEAD,EACAP,EACAb,EACAV,KAAKE,YAEH6B,GACF,YAAOlB,EAAUkB,KAIvB,GAAiB,qBAAbnB,EAAkC,CACpCd,IAAMkC,EAAc,YAClB,GACAhC,KAAKE,WAAW+B,2BAChBxB,EACA,CAAC,IACDT,KAAKE,YAEH8B,IACFnB,EAAWmB,GAGf,OAAOnB,GAST,EAAF,UAAEqB,qBAAA,SAAqBzB,EAAMb,GACzBE,IAAMC,EAAU,GAIhB,OAHIH,GACF,YAAOG,EAASC,KAAKmC,eAAe1B,EAAMb,IAErCI,KAAKQ,cAAcC,EAAM,CAACV,K,EAhIK,CAAV,KC/BhCqC,MAAM,mDACHC,MAAK,SAAUC,GACd,OAAOA,EAASC,UAEjBF,MAAK,SAAUC,GAEdxC,IAAM0C,GAAc,IAAI,GAAoBC,aAAaH,GACzDI,SAASC,eAAe,OAAOC,UAAYJ,EAAYzB,OAAO8B,WAI9D/C,IAAMgD,EAAgB,IAAI,EAAkB,CAC1CzC,OAAQ,CAAC,WACRoC,aAAaH,GAChBI,SAASC,eACP,SACAC,UAAYE,EAAc/B,OAAO8B,WAEnC/C,IAAMiD,EAAqB,IAAI,EAAkB,CAC/C1C,OAAQ,CAAC,gBACRoC,aAAaH,GAChBI,SAASC,eACP,cACAC,UAAYG,EAAmBhC,OAAO8B,gB","file":"getfeatureinfo-layers.js","sourcesContent":["/**\r\n * @module ol/format/WMSGetFeatureInfo\r\n */\r\nimport GML2 from './GML2.js';\r\nimport XMLFeature from './XMLFeature.js';\r\nimport {assign} from '../obj.js';\r\nimport {extend, includes} from '../array.js';\r\nimport {makeArrayPusher, makeStructureNS, pushParseAndPop} from '../xml.js';\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {Array<string>} [layers] If set, only features of the given layers will be returned by the format when read.\r\n */\r\n\r\n/**\r\n * @const\r\n * @type {string}\r\n */\r\nconst featureIdentifier = '_feature';\r\n\r\n/**\r\n * @const\r\n * @type {string}\r\n */\r\nconst layerIdentifier = '_layer';\r\n\r\n/**\r\n * @classdesc\r\n * Format for reading WMSGetFeatureInfo format. It uses\r\n * {@link module:ol/format/GML2~GML2} to read features.\r\n *\r\n * @api\r\n */\r\nclass WMSGetFeatureInfo extends XMLFeature {\r\n  /**\r\n   * @param {Options=} opt_options Options.\r\n   */\r\n  constructor(opt_options) {\r\n    super();\r\n\r\n    const options = opt_options ? opt_options : {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.featureNS_ = 'http://mapserver.gis.umn.edu/mapserver';\r\n\r\n    /**\r\n     * @private\r\n     * @type {GML2}\r\n     */\r\n    this.gmlFormat_ = new GML2();\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<string>}\r\n     */\r\n    this.layers_ = options.layers ? options.layers : null;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<string>} layers\r\n   */\r\n  getLayers() {\r\n    return this.layers_;\r\n  }\r\n\r\n  /**\r\n   * @param {Array<string>} layers Layers to parse.\r\n   */\r\n  setLayers(layers) {\r\n    this.layers_ = layers;\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   * @return {Array<import(\"../Feature.js\").default>} Features.\r\n   * @private\r\n   */\r\n  readFeatures_(node, objectStack) {\r\n    node.setAttribute('namespaceURI', this.featureNS_);\r\n    const localName = node.localName;\r\n    /** @type {Array<import(\"../Feature.js\").default>} */\r\n    let features = [];\r\n    if (node.childNodes.length === 0) {\r\n      return features;\r\n    }\r\n    if (localName == 'msGMLOutput') {\r\n      for (let i = 0, ii = node.childNodes.length; i < ii; i++) {\r\n        const layer = node.childNodes[i];\r\n        if (layer.nodeType !== Node.ELEMENT_NODE) {\r\n          continue;\r\n        }\r\n\r\n        const layerElement = /** @type {Element} */ (layer);\r\n        const context = objectStack[0];\r\n\r\n        const toRemove = layerIdentifier;\r\n        const layerName = layerElement.localName.replace(toRemove, '');\r\n\r\n        if (this.layers_ && !includes(this.layers_, layerName)) {\r\n          continue;\r\n        }\r\n\r\n        const featureType = layerName + featureIdentifier;\r\n\r\n        context['featureType'] = featureType;\r\n        context['featureNS'] = this.featureNS_;\r\n\r\n        /** @type {Object<string, import(\"../xml.js\").Parser>} */\r\n        const parsers = {};\r\n        parsers[featureType] = makeArrayPusher(\r\n          this.gmlFormat_.readFeatureElement,\r\n          this.gmlFormat_\r\n        );\r\n        const parsersNS = makeStructureNS(\r\n          [context['featureNS'], null],\r\n          parsers\r\n        );\r\n        layerElement.setAttribute('namespaceURI', this.featureNS_);\r\n        const layerFeatures = pushParseAndPop(\r\n          [],\r\n          // @ts-ignore\r\n          parsersNS,\r\n          layerElement,\r\n          objectStack,\r\n          this.gmlFormat_\r\n        );\r\n        if (layerFeatures) {\r\n          extend(features, layerFeatures);\r\n        }\r\n      }\r\n    }\r\n    if (localName == 'FeatureCollection') {\r\n      const gmlFeatures = pushParseAndPop(\r\n        [],\r\n        this.gmlFormat_.FEATURE_COLLECTION_PARSERS,\r\n        node,\r\n        [{}],\r\n        this.gmlFormat_\r\n      );\r\n      if (gmlFeatures) {\r\n        features = gmlFeatures;\r\n      }\r\n    }\r\n    return features;\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {Element} node Node.\r\n   * @param {import(\"./Feature.js\").ReadOptions=} opt_options Options.\r\n   * @return {Array<import(\"../Feature.js\").default>} Features.\r\n   */\r\n  readFeaturesFromNode(node, opt_options) {\r\n    const options = {};\r\n    if (opt_options) {\r\n      assign(options, this.getReadOptions(node, opt_options));\r\n    }\r\n    return this.readFeatures_(node, [options]);\r\n  }\r\n}\r\n\r\nexport default WMSGetFeatureInfo;\r\n","import WMSGetFeatureInfo from '../src/ol/format/WMSGetFeatureInfo.js';\r\n\r\nfetch('data/wmsgetfeatureinfo/osm-restaurant-hotel.xml')\r\n  .then(function (response) {\r\n    return response.text();\r\n  })\r\n  .then(function (response) {\r\n    // this is the standard way to read the features\r\n    const allFeatures = new WMSGetFeatureInfo().readFeatures(response);\r\n    document.getElementById('all').innerText = allFeatures.length.toString();\r\n\r\n    // when specifying the 'layers' options, only the features of those\r\n    // layers are returned by the format\r\n    const hotelFeatures = new WMSGetFeatureInfo({\r\n      layers: ['hotel'],\r\n    }).readFeatures(response);\r\n    document.getElementById(\r\n      'hotel'\r\n    ).innerText = hotelFeatures.length.toString();\r\n\r\n    const restaurantFeatures = new WMSGetFeatureInfo({\r\n      layers: ['restaurant'],\r\n    }).readFeatures(response);\r\n    document.getElementById(\r\n      'restaurant'\r\n    ).innerText = restaurantFeatures.length.toString();\r\n  });\r\n"],"sourceRoot":""}