{"version":3,"sources":["webpack:///../src/ol/format/GML3.js","webpack:///../src/ol/format/GML32.js","webpack:///../src/ol/format/filter/Filter.js","webpack:///../src/ol/format/filter/LogicalNary.js","webpack:///../src/ol/format/filter/And.js","webpack:///../src/ol/format/filter/Bbox.js","webpack:///../src/ol/format/filter/Comparison.js","webpack:///../src/ol/format/filter/ComparisonBinary.js","webpack:///../src/ol/format/filter/EqualTo.js","webpack:///../src/ol/format/filter/IsLike.js","webpack:///../src/ol/format/filter.js","webpack:///../src/ol/format/WFS.js","webpack:///./vector-wfs-getfeature.js"],"names":["schemaLocation","MULTIGEOMETRY_TO_MEMBER_NODENAME","opt_options","const","options","super","this","surface_","undefined","surface","curve_","curve","multiCurve_","multiCurve","multiSurface_","multiSurface","hasZ","readMultiCurve","node","objectStack","lineStrings","MULTICURVE_PARSERS","MultiLineString","readMultiSurface","polygons","MULTISURFACE_PARSERS","MultiPolygon","curveMemberParser","CURVEMEMBER_PARSERS","surfaceMemberParser","SURFACEMEMBER_PARSERS","readPatch","PATCHES_PARSERS","readSegment","SEGMENTS_PARSERS","readPolygonPatch","FLAT_LINEAR_RINGS_PARSERS","readLineStringSegment","GEOMETRY_FLAT_COORDINATES_PARSERS","interiorParser","flatLinearRing","RING_PARSERS","length","push","exteriorParser","readSurface","flatLinearRings","SURFACE_PARSERS","i","ii","flatCoordinates","ends","Polygon","GeometryLayout","XYZ","readCurve","CURVE_PARSERS","LineString","readEnvelope","ENVELOPE_PARSERS","readFlatPos","let","m","s","re","exec","parseFloat","substr","containerSrs","axisOrientation","getAxisOrientation","y","x","len","readFlatPosList","replace","context","contextDimension","z","coords","split","dim","getAttribute","writePos_","value","srsDimension","setAttribute","srsName","point","getCoordinates","getCoords_","opt_srsName","opt_hasZ","writePosList_","points","parts","Array","join","writePoint","geometry","pos","namespaceURI","appendChild","writeEnvelope","extent","values","ENVELOPE_SERIALIZERS","writeLinearRing","posList","RING_NODE_FACTORY_","opt_nodeName","parentNode","exteriorWritten","writeSurfaceOrPolygon","nodeName","rings","getLinearRings","RING_SERIALIZERS","patches","writeSurfacePatches_","writeCurveOrLineString","segments","writeCurveSegments_","writeMultiSurfaceOrPolygon","getPolygons","SURFACEORPOLYGONMEMBER_SERIALIZERS","MULTIGEOMETRY_MEMBER_NODE_FACTORY_","writeMultiPoint","getPoints","POINTMEMBER_SERIALIZERS","writeMultiCurveOrLineString","lines","getLineStrings","LINESTRINGORCURVEMEMBER_SERIALIZERS","writeRing","ring","linearRing","writeSurfaceOrPolygonMember","polygon","child","GEOMETRY_NODE_FACTORY_","writePointMember","writeLineStringOrCurveMember","line","writeGeometryElement","item","isArray","GEOMETRY_SERIALIZERS","writeFeatureElement","feature","fid","getId","featureNS","geometryName","getGeometryName","serializers","keys","hasProperties","properties","getProperties","key","writeFeatureMembers_","features","featureType","namespace","getType","writeGeometryNode","adaptOptions","geom","writeFeaturesNode","setAttributeNS","prototype","GML2","readFlatCoordinates","GEOMETRY_PARSERS","readPoint","readMultiPoint","readLineString","readMultiLineString","readLinearRing","readPolygon","readMultiPolygon","writeFeatures","GML32","MULTIPOINT_PARSERS","pointMemberParser","MULTILINESTRING_PARSERS","lineStringMemberParser","MULTIPOLYGON_PARSERS","polygonMemberParser","POINTMEMBER_PARSERS","readFlatCoordinatesFromNode","LINESTRINGMEMBER_PARSERS","POLYGONMEMBER_PARSERS","readFlatLinearRing","tagName","tagName_","getTagName","conditions","slice","call","arguments","Error","propertyName","expression","opt_matchCase","matchCase","pattern","opt_wildCard","opt_singleChar","opt_escapeChar","wildCard","singleChar","escapeChar","and","params","concat","Function","bind","apply","FEATURE_COLLECTION_PARSERS","readGeometryElement","readFeaturesInternal","TRANSACTION_SUMMARY_PARSERS","TRANSACTION_RESPONSE_PARSERS","readTransactionSummary","readInsertResults","QUERY_SERIALIZERS","TRANSACTION_SERIALIZERS","writeFeature","writeUpdate","writeDelete","writeProperty","writeNative","FEATURE_PREFIX","XMLNS","OGCNS","WFSNS","FESNS","SCHEMA_LOCATIONS","GML_FORMATS","version_","version","featureType_","featureNS_","gmlFormat_","gmlFormat","schemaLocation_","getFeatureType","setFeatureType","readFeaturesFromNode","getReadOptions","featuresNS","readTransactionResponse","source","doc","readTransactionResponseFromDocument","readTransactionResponseFromNode","readFeatureCollectionMetadata","readFeatureCollectionMetadataFromDocument","readFeatureCollectionMetadataFromNode","n","nextSibling","nodeType","Node","ELEMENT_NODE","result","writeGetFeature","handle","outputFormat","maxFeatures","String","resultType","startIndex","count","viewParams","featurePrefix","propertyNames","featureTypes","filter","bbox","combineBboxAndFilter","forEach","completeFilter","name","opt_filter","bboxFilter","writeTransaction","inserts","updates","deletes","baseObj","gmlOptions","request","gmlVersion","createTransactionRequest","serializeTransactionRequest","nativeElements","readProjectionFromDocument","firstChild","readProjectionFromNode","firstElementChild","nextElementSibling","childNodes","pop","type","OGC_FID_PARSERS","fidParser","INSERT_RESULTS_PARSERS","writeOgcFidFilter","ns","getTypeName","prefix","indexOf","typeName","getKeys","get","pair","nativeElement","vendorId","safeToIgnore","GETFEATURE_SERIALIZERS","writeQuery","writeDuringFilter","writeLogicalFilter","writeNotFilter","writeBboxFilter","writeSpatialFilter","writeDWithinFilter","writeComparisonFilter","writeIsNullFilter","writeIsBetweenFilter","writeIsLikeFilter","typeNameAttr","getFilterNS","writeFilterCondition","parent","format","writePropertyName","distance","toString","unit","writeExpression","timePeriod","begin","writeTimeInstant","end","condition","writeLiteral","lowerBoundary","upperBoundary","property","time","timeInstant","timePosition","vectorSource","Vector","vector","style","Style","stroke","Stroke","color","width","raster","Tile","attributions","url","maxZoom","map","Map","layers","target","document","getElementById","view","View","center","zoom","featureRequest","equalTo","fetch","method","body","XMLSerializer","serializeToString","then","response","json","GeoJSON","readFeatures","addFeatures","getView","fit","getExtent"],"mappings":"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","file":"vector-wfs-getfeature.js","sourcesContent":["/**\r\n * @module ol/format/GML3\r\n */\r\nimport GML2 from './GML2.js';\r\nimport GMLBase, {GMLNS} from './GMLBase.js';\r\nimport GeometryLayout from '../geom/GeometryLayout.js';\r\nimport LineString from '../geom/LineString.js';\r\nimport MultiLineString from '../geom/MultiLineString.js';\r\nimport MultiPolygon from '../geom/MultiPolygon.js';\r\nimport Polygon from '../geom/Polygon.js';\r\nimport {\r\n  OBJECT_PROPERTY_NODE_FACTORY,\r\n  XML_SCHEMA_INSTANCE_URI,\r\n  createElementNS,\r\n  getAllTextContent,\r\n  makeArrayPusher,\r\n  makeChildAppender,\r\n  makeReplacer,\r\n  makeSimpleNodeFactory,\r\n  parseNode,\r\n  pushParseAndPop,\r\n  pushSerializeAndPop,\r\n} from '../xml.js';\r\nimport {assign} from '../obj.js';\r\nimport {createOrUpdate} from '../extent.js';\r\nimport {extend} from '../array.js';\r\nimport {get as getProjection} from '../proj.js';\r\nimport {readNonNegativeIntegerString, writeStringTextNode} from './xsd.js';\r\nimport {\r\n  transformExtentWithOptions,\r\n  transformGeometryWithOptions,\r\n} from './Feature.js';\r\n\r\n/**\r\n * @const\r\n * @type {string}\r\n * @private\r\n */\r\nconst schemaLocation =\r\n  GMLNS +\r\n  ' http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/' +\r\n  '1.0.0/gmlsf.xsd';\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, string>}\r\n */\r\nconst MULTIGEOMETRY_TO_MEMBER_NODENAME = {\r\n  'MultiLineString': 'lineStringMember',\r\n  'MultiCurve': 'curveMember',\r\n  'MultiPolygon': 'polygonMember',\r\n  'MultiSurface': 'surfaceMember',\r\n};\r\n\r\n/**\r\n * @classdesc\r\n * Feature format for reading and writing data in the GML format\r\n * version 3.1.1.\r\n * Currently only supports GML 3.1.1 Simple Features profile.\r\n *\r\n * @api\r\n */\r\nclass GML3 extends GMLBase {\r\n  /**\r\n   * @param {import(\"./GMLBase.js\").Options=} opt_options Optional configuration object.\r\n   */\r\n  constructor(opt_options) {\r\n    const options =\r\n      /** @type {import(\"./GMLBase.js\").Options} */\r\n      (opt_options ? opt_options : {});\r\n\r\n    super(options);\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.surface_ = options.surface !== undefined ? options.surface : false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.curve_ = options.curve !== undefined ? options.curve : false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.multiCurve_ =\r\n      options.multiCurve !== undefined ? options.multiCurve : true;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.multiSurface_ =\r\n      options.multiSurface !== undefined ? options.multiSurface : true;\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    this.schemaLocation = options.schemaLocation\r\n      ? options.schemaLocation\r\n      : schemaLocation;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.hasZ = options.hasZ !== undefined ? options.hasZ : false;\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   * @return {MultiLineString|undefined} MultiLineString.\r\n   */\r\n  readMultiCurve(node, objectStack) {\r\n    /** @type {Array<LineString>} */\r\n    const lineStrings = pushParseAndPop(\r\n      [],\r\n      this.MULTICURVE_PARSERS,\r\n      node,\r\n      objectStack,\r\n      this\r\n    );\r\n    if (lineStrings) {\r\n      const multiLineString = new MultiLineString(lineStrings);\r\n      return multiLineString;\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   * @return {MultiPolygon|undefined} MultiPolygon.\r\n   */\r\n  readMultiSurface(node, objectStack) {\r\n    /** @type {Array<Polygon>} */\r\n    const polygons = pushParseAndPop(\r\n      [],\r\n      this.MULTISURFACE_PARSERS,\r\n      node,\r\n      objectStack,\r\n      this\r\n    );\r\n    if (polygons) {\r\n      return new MultiPolygon(polygons);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   */\r\n  curveMemberParser(node, objectStack) {\r\n    parseNode(this.CURVEMEMBER_PARSERS, node, objectStack, this);\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   */\r\n  surfaceMemberParser(node, objectStack) {\r\n    parseNode(this.SURFACEMEMBER_PARSERS, node, objectStack, this);\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   * @return {Array<(Array<number>)>|undefined} flat coordinates.\r\n   */\r\n  readPatch(node, objectStack) {\r\n    return pushParseAndPop(\r\n      [null],\r\n      this.PATCHES_PARSERS,\r\n      node,\r\n      objectStack,\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   * @return {Array<number>|undefined} flat coordinates.\r\n   */\r\n  readSegment(node, objectStack) {\r\n    return pushParseAndPop(\r\n      [null],\r\n      this.SEGMENTS_PARSERS,\r\n      node,\r\n      objectStack,\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   * @return {Array<(Array<number>)>|undefined} flat coordinates.\r\n   */\r\n  readPolygonPatch(node, objectStack) {\r\n    return pushParseAndPop(\r\n      [null],\r\n      this.FLAT_LINEAR_RINGS_PARSERS,\r\n      node,\r\n      objectStack,\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   * @return {Array<number>|undefined} flat coordinates.\r\n   */\r\n  readLineStringSegment(node, objectStack) {\r\n    return pushParseAndPop(\r\n      [null],\r\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\r\n      node,\r\n      objectStack,\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   */\r\n  interiorParser(node, objectStack) {\r\n    /** @type {Array<number>|undefined} */\r\n    const flatLinearRing = pushParseAndPop(\r\n      undefined,\r\n      this.RING_PARSERS,\r\n      node,\r\n      objectStack,\r\n      this\r\n    );\r\n    if (flatLinearRing) {\r\n      const flatLinearRings =\r\n        /** @type {Array<Array<number>>} */\r\n        (objectStack[objectStack.length - 1]);\r\n      flatLinearRings.push(flatLinearRing);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   */\r\n  exteriorParser(node, objectStack) {\r\n    /** @type {Array<number>|undefined} */\r\n    const flatLinearRing = pushParseAndPop(\r\n      undefined,\r\n      this.RING_PARSERS,\r\n      node,\r\n      objectStack,\r\n      this\r\n    );\r\n    if (flatLinearRing) {\r\n      const flatLinearRings =\r\n        /** @type {Array<Array<number>>} */\r\n        (objectStack[objectStack.length - 1]);\r\n      flatLinearRings[0] = flatLinearRing;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   * @return {Polygon|undefined} Polygon.\r\n   */\r\n  readSurface(node, objectStack) {\r\n    /** @type {Array<Array<number>>} */\r\n    const flatLinearRings = pushParseAndPop(\r\n      [null],\r\n      this.SURFACE_PARSERS,\r\n      node,\r\n      objectStack,\r\n      this\r\n    );\r\n    if (flatLinearRings && flatLinearRings[0]) {\r\n      const flatCoordinates = flatLinearRings[0];\r\n      const ends = [flatCoordinates.length];\r\n      let i, ii;\r\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\r\n        extend(flatCoordinates, flatLinearRings[i]);\r\n        ends.push(flatCoordinates.length);\r\n      }\r\n      return new Polygon(flatCoordinates, GeometryLayout.XYZ, ends);\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   * @return {LineString|undefined} LineString.\r\n   */\r\n  readCurve(node, objectStack) {\r\n    /** @type {Array<number>} */\r\n    const flatCoordinates = pushParseAndPop(\r\n      [null],\r\n      this.CURVE_PARSERS,\r\n      node,\r\n      objectStack,\r\n      this\r\n    );\r\n    if (flatCoordinates) {\r\n      const lineString = new LineString(flatCoordinates, GeometryLayout.XYZ);\r\n      return lineString;\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   * @return {import(\"../extent.js\").Extent|undefined} Envelope.\r\n   */\r\n  readEnvelope(node, objectStack) {\r\n    /** @type {Array<number>} */\r\n    const flatCoordinates = pushParseAndPop(\r\n      [null],\r\n      this.ENVELOPE_PARSERS,\r\n      node,\r\n      objectStack,\r\n      this\r\n    );\r\n    return createOrUpdate(\r\n      flatCoordinates[1][0],\r\n      flatCoordinates[1][1],\r\n      flatCoordinates[2][0],\r\n      flatCoordinates[2][1]\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {Node} node Node.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   * @return {Array<number>|undefined} Flat coordinates.\r\n   */\r\n  readFlatPos(node, objectStack) {\r\n    let s = getAllTextContent(node, false);\r\n    const re = /^\\s*([+\\-]?\\d*\\.?\\d+(?:[eE][+\\-]?\\d+)?)\\s*/;\r\n    /** @type {Array<number>} */\r\n    const flatCoordinates = [];\r\n    let m;\r\n    while ((m = re.exec(s))) {\r\n      flatCoordinates.push(parseFloat(m[1]));\r\n      s = s.substr(m[0].length);\r\n    }\r\n    if (s !== '') {\r\n      return undefined;\r\n    }\r\n    const context = objectStack[0];\r\n    const containerSrs = context['srsName'];\r\n    let axisOrientation = 'enu';\r\n    if (containerSrs) {\r\n      const proj = getProjection(containerSrs);\r\n      axisOrientation = proj.getAxisOrientation();\r\n    }\r\n    if (axisOrientation === 'neu') {\r\n      let i, ii;\r\n      for (i = 0, ii = flatCoordinates.length; i < ii; i += 3) {\r\n        const y = flatCoordinates[i];\r\n        const x = flatCoordinates[i + 1];\r\n        flatCoordinates[i] = x;\r\n        flatCoordinates[i + 1] = y;\r\n      }\r\n    }\r\n    const len = flatCoordinates.length;\r\n    if (len == 2) {\r\n      flatCoordinates.push(0);\r\n    }\r\n    if (len === 0) {\r\n      return undefined;\r\n    }\r\n    return flatCoordinates;\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   * @return {Array<number>|undefined} Flat coordinates.\r\n   */\r\n  readFlatPosList(node, objectStack) {\r\n    const s = getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\r\n    const context = objectStack[0];\r\n    const containerSrs = context['srsName'];\r\n    const contextDimension = context['srsDimension'];\r\n    let axisOrientation = 'enu';\r\n    if (containerSrs) {\r\n      const proj = getProjection(containerSrs);\r\n      axisOrientation = proj.getAxisOrientation();\r\n    }\r\n    const coords = s.split(/\\s+/);\r\n    // The \"dimension\" attribute is from the GML 3.0.1 spec.\r\n    let dim = 2;\r\n    if (node.getAttribute('srsDimension')) {\r\n      dim = readNonNegativeIntegerString(node.getAttribute('srsDimension'));\r\n    } else if (node.getAttribute('dimension')) {\r\n      dim = readNonNegativeIntegerString(node.getAttribute('dimension'));\r\n    } else if (\r\n      /** @type {Element} */ (node.parentNode).getAttribute('srsDimension')\r\n    ) {\r\n      dim = readNonNegativeIntegerString(\r\n        /** @type {Element} */ (node.parentNode).getAttribute('srsDimension')\r\n      );\r\n    } else if (contextDimension) {\r\n      dim = readNonNegativeIntegerString(contextDimension);\r\n    }\r\n    let x, y, z;\r\n    const flatCoordinates = [];\r\n    for (let i = 0, ii = coords.length; i < ii; i += dim) {\r\n      x = parseFloat(coords[i]);\r\n      y = parseFloat(coords[i + 1]);\r\n      z = dim === 3 ? parseFloat(coords[i + 2]) : 0;\r\n      if (axisOrientation.substr(0, 2) === 'en') {\r\n        flatCoordinates.push(x, y, z);\r\n      } else {\r\n        flatCoordinates.push(y, x, z);\r\n      }\r\n    }\r\n    return flatCoordinates;\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {import(\"../geom/Point.js\").default} value Point geometry.\r\n   * @param {Array<*>} objectStack Node stack.\r\n   * @private\r\n   */\r\n  writePos_(node, value, objectStack) {\r\n    const context = objectStack[objectStack.length - 1];\r\n    const hasZ = context['hasZ'];\r\n    const srsDimension = hasZ ? '3' : '2';\r\n    node.setAttribute('srsDimension', srsDimension);\r\n    const srsName = context['srsName'];\r\n    let axisOrientation = 'enu';\r\n    if (srsName) {\r\n      axisOrientation = getProjection(srsName).getAxisOrientation();\r\n    }\r\n    const point = value.getCoordinates();\r\n    let coords;\r\n    // only 2d for simple features profile\r\n    if (axisOrientation.substr(0, 2) === 'en') {\r\n      coords = point[0] + ' ' + point[1];\r\n    } else {\r\n      coords = point[1] + ' ' + point[0];\r\n    }\r\n    if (hasZ) {\r\n      // For newly created points, Z can be undefined.\r\n      const z = point[2] || 0;\r\n      coords += ' ' + z;\r\n    }\r\n    writeStringTextNode(node, coords);\r\n  }\r\n\r\n  /**\r\n   * @param {Array<number>} point Point geometry.\r\n   * @param {string=} opt_srsName Optional srsName\r\n   * @param {boolean=} opt_hasZ whether the geometry has a Z coordinate (is 3D) or not.\r\n   * @return {string} The coords string.\r\n   * @private\r\n   */\r\n  getCoords_(point, opt_srsName, opt_hasZ) {\r\n    let axisOrientation = 'enu';\r\n    if (opt_srsName) {\r\n      axisOrientation = getProjection(opt_srsName).getAxisOrientation();\r\n    }\r\n    let coords =\r\n      axisOrientation.substr(0, 2) === 'en'\r\n        ? point[0] + ' ' + point[1]\r\n        : point[1] + ' ' + point[0];\r\n    if (opt_hasZ) {\r\n      // For newly created points, Z can be undefined.\r\n      const z = point[2] || 0;\r\n      coords += ' ' + z;\r\n    }\r\n\r\n    return coords;\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {LineString|import(\"../geom/LinearRing.js\").default} value Geometry.\r\n   * @param {Array<*>} objectStack Node stack.\r\n   * @private\r\n   */\r\n  writePosList_(node, value, objectStack) {\r\n    const context = objectStack[objectStack.length - 1];\r\n    const hasZ = context['hasZ'];\r\n    const srsDimension = hasZ ? '3' : '2';\r\n    node.setAttribute('srsDimension', srsDimension);\r\n    const srsName = context['srsName'];\r\n    // only 2d for simple features profile\r\n    const points = value.getCoordinates();\r\n    const len = points.length;\r\n    const parts = new Array(len);\r\n    let point;\r\n    for (let i = 0; i < len; ++i) {\r\n      point = points[i];\r\n      parts[i] = this.getCoords_(point, srsName, hasZ);\r\n    }\r\n    writeStringTextNode(node, parts.join(' '));\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {import(\"../geom/Point.js\").default} geometry Point geometry.\r\n   * @param {Array<*>} objectStack Node stack.\r\n   */\r\n  writePoint(node, geometry, objectStack) {\r\n    const context = objectStack[objectStack.length - 1];\r\n    const srsName = context['srsName'];\r\n    if (srsName) {\r\n      node.setAttribute('srsName', srsName);\r\n    }\r\n    const pos = createElementNS(node.namespaceURI, 'pos');\r\n    node.appendChild(pos);\r\n    this.writePos_(pos, geometry, objectStack);\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {Array<*>} objectStack Node stack.\r\n   */\r\n  writeEnvelope(node, extent, objectStack) {\r\n    const context = objectStack[objectStack.length - 1];\r\n    const srsName = context['srsName'];\r\n    if (srsName) {\r\n      node.setAttribute('srsName', srsName);\r\n    }\r\n    const keys = ['lowerCorner', 'upperCorner'];\r\n    const values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\r\n    pushSerializeAndPop(\r\n      /** @type {import(\"../xml.js\").NodeStackItem} */\r\n      ({node: node}),\r\n      this.ENVELOPE_SERIALIZERS,\r\n      OBJECT_PROPERTY_NODE_FACTORY,\r\n      values,\r\n      objectStack,\r\n      keys,\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {import(\"../geom/LinearRing.js\").default} geometry LinearRing geometry.\r\n   * @param {Array<*>} objectStack Node stack.\r\n   */\r\n  writeLinearRing(node, geometry, objectStack) {\r\n    const context = objectStack[objectStack.length - 1];\r\n    const srsName = context['srsName'];\r\n    if (srsName) {\r\n      node.setAttribute('srsName', srsName);\r\n    }\r\n    const posList = createElementNS(node.namespaceURI, 'posList');\r\n    node.appendChild(posList);\r\n    this.writePosList_(posList, geometry, objectStack);\r\n  }\r\n\r\n  /**\r\n   * @param {*} value Value.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   * @param {string=} opt_nodeName Node name.\r\n   * @return {Node} Node.\r\n   * @private\r\n   */\r\n  RING_NODE_FACTORY_(value, objectStack, opt_nodeName) {\r\n    const context = objectStack[objectStack.length - 1];\r\n    const parentNode = context.node;\r\n    const exteriorWritten = context['exteriorWritten'];\r\n    if (exteriorWritten === undefined) {\r\n      context['exteriorWritten'] = true;\r\n    }\r\n    return createElementNS(\r\n      parentNode.namespaceURI,\r\n      exteriorWritten !== undefined ? 'interior' : 'exterior'\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {Polygon} geometry Polygon geometry.\r\n   * @param {Array<*>} objectStack Node stack.\r\n   */\r\n  writeSurfaceOrPolygon(node, geometry, objectStack) {\r\n    const context = objectStack[objectStack.length - 1];\r\n    const hasZ = context['hasZ'];\r\n    const srsName = context['srsName'];\r\n    if (node.nodeName !== 'PolygonPatch' && srsName) {\r\n      node.setAttribute('srsName', srsName);\r\n    }\r\n    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\r\n      const rings = geometry.getLinearRings();\r\n      pushSerializeAndPop(\r\n        {node: node, hasZ: hasZ, srsName: srsName},\r\n        this.RING_SERIALIZERS,\r\n        this.RING_NODE_FACTORY_,\r\n        rings,\r\n        objectStack,\r\n        undefined,\r\n        this\r\n      );\r\n    } else if (node.nodeName === 'Surface') {\r\n      const patches = createElementNS(node.namespaceURI, 'patches');\r\n      node.appendChild(patches);\r\n      this.writeSurfacePatches_(patches, geometry, objectStack);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {LineString} geometry LineString geometry.\r\n   * @param {Array<*>} objectStack Node stack.\r\n   */\r\n  writeCurveOrLineString(node, geometry, objectStack) {\r\n    const context = objectStack[objectStack.length - 1];\r\n    const srsName = context['srsName'];\r\n    if (node.nodeName !== 'LineStringSegment' && srsName) {\r\n      node.setAttribute('srsName', srsName);\r\n    }\r\n    if (\r\n      node.nodeName === 'LineString' ||\r\n      node.nodeName === 'LineStringSegment'\r\n    ) {\r\n      const posList = createElementNS(node.namespaceURI, 'posList');\r\n      node.appendChild(posList);\r\n      this.writePosList_(posList, geometry, objectStack);\r\n    } else if (node.nodeName === 'Curve') {\r\n      const segments = createElementNS(node.namespaceURI, 'segments');\r\n      node.appendChild(segments);\r\n      this.writeCurveSegments_(segments, geometry, objectStack);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {MultiPolygon} geometry MultiPolygon geometry.\r\n   * @param {Array<*>} objectStack Node stack.\r\n   */\r\n  writeMultiSurfaceOrPolygon(node, geometry, objectStack) {\r\n    const context = objectStack[objectStack.length - 1];\r\n    const hasZ = context['hasZ'];\r\n    const srsName = context['srsName'];\r\n    const surface = context['surface'];\r\n    if (srsName) {\r\n      node.setAttribute('srsName', srsName);\r\n    }\r\n    const polygons = geometry.getPolygons();\r\n    pushSerializeAndPop(\r\n      {node: node, hasZ: hasZ, srsName: srsName, surface: surface},\r\n      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,\r\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\r\n      polygons,\r\n      objectStack,\r\n      undefined,\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry MultiPoint geometry.\r\n   * @param {Array<*>} objectStack Node stack.\r\n   */\r\n  writeMultiPoint(node, geometry, objectStack) {\r\n    const context = objectStack[objectStack.length - 1];\r\n    const srsName = context['srsName'];\r\n    const hasZ = context['hasZ'];\r\n    if (srsName) {\r\n      node.setAttribute('srsName', srsName);\r\n    }\r\n    const points = geometry.getPoints();\r\n    pushSerializeAndPop(\r\n      {node: node, hasZ: hasZ, srsName: srsName},\r\n      this.POINTMEMBER_SERIALIZERS,\r\n      makeSimpleNodeFactory('pointMember'),\r\n      points,\r\n      objectStack,\r\n      undefined,\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {MultiLineString} geometry MultiLineString geometry.\r\n   * @param {Array<*>} objectStack Node stack.\r\n   */\r\n  writeMultiCurveOrLineString(node, geometry, objectStack) {\r\n    const context = objectStack[objectStack.length - 1];\r\n    const hasZ = context['hasZ'];\r\n    const srsName = context['srsName'];\r\n    const curve = context['curve'];\r\n    if (srsName) {\r\n      node.setAttribute('srsName', srsName);\r\n    }\r\n    const lines = geometry.getLineStrings();\r\n    pushSerializeAndPop(\r\n      {node: node, hasZ: hasZ, srsName: srsName, curve: curve},\r\n      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,\r\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\r\n      lines,\r\n      objectStack,\r\n      undefined,\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {Node} node Node.\r\n   * @param {import(\"../geom/LinearRing.js\").default} ring LinearRing geometry.\r\n   * @param {Array<*>} objectStack Node stack.\r\n   */\r\n  writeRing(node, ring, objectStack) {\r\n    const linearRing = createElementNS(node.namespaceURI, 'LinearRing');\r\n    node.appendChild(linearRing);\r\n    this.writeLinearRing(linearRing, ring, objectStack);\r\n  }\r\n\r\n  /**\r\n   * @param {Node} node Node.\r\n   * @param {Polygon} polygon Polygon geometry.\r\n   * @param {Array<*>} objectStack Node stack.\r\n   */\r\n  writeSurfaceOrPolygonMember(node, polygon, objectStack) {\r\n    const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);\r\n    if (child) {\r\n      node.appendChild(child);\r\n      this.writeSurfaceOrPolygon(child, polygon, objectStack);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Node} node Node.\r\n   * @param {import(\"../geom/Point.js\").default} point Point geometry.\r\n   * @param {Array<*>} objectStack Node stack.\r\n   */\r\n  writePointMember(node, point, objectStack) {\r\n    const child = createElementNS(node.namespaceURI, 'Point');\r\n    node.appendChild(child);\r\n    this.writePoint(child, point, objectStack);\r\n  }\r\n\r\n  /**\r\n   * @param {Node} node Node.\r\n   * @param {LineString} line LineString geometry.\r\n   * @param {Array<*>} objectStack Node stack.\r\n   */\r\n  writeLineStringOrCurveMember(node, line, objectStack) {\r\n    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\r\n    if (child) {\r\n      node.appendChild(child);\r\n      this.writeCurveOrLineString(child, line, objectStack);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Node} node Node.\r\n   * @param {Polygon} polygon Polygon geometry.\r\n   * @param {Array<*>} objectStack Node stack.\r\n   * @private\r\n   */\r\n  writeSurfacePatches_(node, polygon, objectStack) {\r\n    const child = createElementNS(node.namespaceURI, 'PolygonPatch');\r\n    node.appendChild(child);\r\n    this.writeSurfaceOrPolygon(child, polygon, objectStack);\r\n  }\r\n\r\n  /**\r\n   * @param {Node} node Node.\r\n   * @param {LineString} line LineString geometry.\r\n   * @param {Array<*>} objectStack Node stack.\r\n   * @private\r\n   */\r\n  writeCurveSegments_(node, line, objectStack) {\r\n    const child = createElementNS(node.namespaceURI, 'LineStringSegment');\r\n    node.appendChild(child);\r\n    this.writeCurveOrLineString(child, line, objectStack);\r\n  }\r\n\r\n  /**\r\n   * @param {Node} node Node.\r\n   * @param {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} geometry Geometry.\r\n   * @param {Array<*>} objectStack Node stack.\r\n   */\r\n  writeGeometryElement(node, geometry, objectStack) {\r\n    const context = /** @type {import(\"./Feature.js\").WriteOptions} */ (objectStack[\r\n      objectStack.length - 1\r\n    ]);\r\n    const item = assign({}, context);\r\n    item['node'] = node;\r\n    let value;\r\n    if (Array.isArray(geometry)) {\r\n      value = transformExtentWithOptions(\r\n        /** @type {import(\"../extent.js\").Extent} */ (geometry),\r\n        context\r\n      );\r\n    } else {\r\n      value = transformGeometryWithOptions(\r\n        /** @type {import(\"../geom/Geometry.js\").default} */ (geometry),\r\n        true,\r\n        context\r\n      );\r\n    }\r\n    pushSerializeAndPop(\r\n      /** @type {import(\"../xml.js\").NodeStackItem} */\r\n      (item),\r\n      this.GEOMETRY_SERIALIZERS,\r\n      this.GEOMETRY_NODE_FACTORY_,\r\n      [value],\r\n      objectStack,\r\n      undefined,\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @param {import(\"../Feature.js\").default} feature Feature.\r\n   * @param {Array<*>} objectStack Node stack.\r\n   */\r\n  writeFeatureElement(node, feature, objectStack) {\r\n    const fid = feature.getId();\r\n    if (fid) {\r\n      node.setAttribute('fid', /** @type {string} */ (fid));\r\n    }\r\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\r\n    const featureNS = context['featureNS'];\r\n    const geometryName = feature.getGeometryName();\r\n    if (!context.serializers) {\r\n      context.serializers = {};\r\n      context.serializers[featureNS] = {};\r\n    }\r\n    const keys = [];\r\n    const values = [];\r\n    if (feature.hasProperties()) {\r\n      const properties = feature.getProperties();\r\n      for (const key in properties) {\r\n        const value = properties[key];\r\n        if (value !== null) {\r\n          keys.push(key);\r\n          values.push(value);\r\n          if (\r\n            key == geometryName ||\r\n            typeof (/** @type {?} */ (value).getSimplifiedGeometry) ===\r\n              'function'\r\n          ) {\r\n            if (!(key in context.serializers[featureNS])) {\r\n              context.serializers[featureNS][key] = makeChildAppender(\r\n                this.writeGeometryElement,\r\n                this\r\n              );\r\n            }\r\n          } else {\r\n            if (!(key in context.serializers[featureNS])) {\r\n              context.serializers[featureNS][key] = makeChildAppender(\r\n                writeStringTextNode\r\n              );\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    const item = assign({}, context);\r\n    item.node = node;\r\n    pushSerializeAndPop(\r\n      /** @type {import(\"../xml.js\").NodeStackItem} */\r\n      (item),\r\n      context.serializers,\r\n      makeSimpleNodeFactory(undefined, featureNS),\r\n      values,\r\n      objectStack,\r\n      keys\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {Node} node Node.\r\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\r\n   * @param {Array<*>} objectStack Node stack.\r\n   * @private\r\n   */\r\n  writeFeatureMembers_(node, features, objectStack) {\r\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\r\n    const featureType = context['featureType'];\r\n    const featureNS = context['featureNS'];\r\n    /** @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>} */\r\n    const serializers = {};\r\n    serializers[featureNS] = {};\r\n    serializers[featureNS][featureType] = makeChildAppender(\r\n      this.writeFeatureElement,\r\n      this\r\n    );\r\n    const item = assign({}, context);\r\n    item.node = node;\r\n    pushSerializeAndPop(\r\n      /** @type {import(\"../xml.js\").NodeStackItem} */\r\n      (item),\r\n      serializers,\r\n      makeSimpleNodeFactory(featureType, featureNS),\r\n      features,\r\n      objectStack\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @const\r\n   * @param {*} value Value.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   * @param {string=} opt_nodeName Node name.\r\n   * @return {Node|undefined} Node.\r\n   * @private\r\n   */\r\n  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, opt_nodeName) {\r\n    const parentNode = objectStack[objectStack.length - 1].node;\r\n    return createElementNS(\r\n      this.namespace,\r\n      MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @const\r\n   * @param {*} value Value.\r\n   * @param {Array<*>} objectStack Object stack.\r\n   * @param {string=} opt_nodeName Node name.\r\n   * @return {Element|undefined} Node.\r\n   * @private\r\n   */\r\n  GEOMETRY_NODE_FACTORY_(value, objectStack, opt_nodeName) {\r\n    const context = objectStack[objectStack.length - 1];\r\n    const multiSurface = context['multiSurface'];\r\n    const surface = context['surface'];\r\n    const curve = context['curve'];\r\n    const multiCurve = context['multiCurve'];\r\n    let nodeName;\r\n    if (!Array.isArray(value)) {\r\n      nodeName = /** @type {import(\"../geom/Geometry.js\").default} */ (value).getType();\r\n      if (nodeName === 'MultiPolygon' && multiSurface === true) {\r\n        nodeName = 'MultiSurface';\r\n      } else if (nodeName === 'Polygon' && surface === true) {\r\n        nodeName = 'Surface';\r\n      } else if (nodeName === 'LineString' && curve === true) {\r\n        nodeName = 'Curve';\r\n      } else if (nodeName === 'MultiLineString' && multiCurve === true) {\r\n        nodeName = 'MultiCurve';\r\n      }\r\n    } else {\r\n      nodeName = 'Envelope';\r\n    }\r\n    return createElementNS(this.namespace, nodeName);\r\n  }\r\n\r\n  /**\r\n   * Encode a geometry in GML 3.1.1 Simple Features.\r\n   *\r\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\r\n   * @param {import(\"./Feature.js\").WriteOptions=} opt_options Options.\r\n   * @return {Node} Node.\r\n   * @api\r\n   */\r\n  writeGeometryNode(geometry, opt_options) {\r\n    opt_options = this.adaptOptions(opt_options);\r\n    const geom = createElementNS(this.namespace, 'geom');\r\n    const context = {\r\n      node: geom,\r\n      hasZ: this.hasZ,\r\n      srsName: this.srsName,\r\n      curve: this.curve_,\r\n      surface: this.surface_,\r\n      multiSurface: this.multiSurface_,\r\n      multiCurve: this.multiCurve_,\r\n    };\r\n    if (opt_options) {\r\n      assign(context, opt_options);\r\n    }\r\n    this.writeGeometryElement(geom, geometry, [context]);\r\n    return geom;\r\n  }\r\n\r\n  /**\r\n   * Encode an array of features in the GML 3.1.1 format as an XML node.\r\n   *\r\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\r\n   * @param {import(\"./Feature.js\").WriteOptions=} opt_options Options.\r\n   * @return {Element} Node.\r\n   * @api\r\n   */\r\n  writeFeaturesNode(features, opt_options) {\r\n    opt_options = this.adaptOptions(opt_options);\r\n    const node = createElementNS(this.namespace, 'featureMembers');\r\n    node.setAttributeNS(\r\n      XML_SCHEMA_INSTANCE_URI,\r\n      'xsi:schemaLocation',\r\n      this.schemaLocation\r\n    );\r\n    const context = {\r\n      srsName: this.srsName,\r\n      hasZ: this.hasZ,\r\n      curve: this.curve_,\r\n      surface: this.surface_,\r\n      multiSurface: this.multiSurface_,\r\n      multiCurve: this.multiCurve_,\r\n      featureNS: this.featureNS,\r\n      featureType: this.featureType,\r\n    };\r\n    if (opt_options) {\r\n      assign(context, opt_options);\r\n    }\r\n    this.writeFeatureMembers_(node, features, [context]);\r\n    return node;\r\n  }\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\r\n  'http://www.opengis.net/gml': {\r\n    'pos': makeReplacer(GML3.prototype.readFlatPos),\r\n    'posList': makeReplacer(GML3.prototype.readFlatPosList),\r\n    'coordinates': makeReplacer(GML2.prototype.readFlatCoordinates),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {\r\n  'http://www.opengis.net/gml': {\r\n    'interior': GML3.prototype.interiorParser,\r\n    'exterior': GML3.prototype.exteriorParser,\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML3.prototype.GEOMETRY_PARSERS = {\r\n  'http://www.opengis.net/gml': {\r\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\r\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\r\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\r\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\r\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\r\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\r\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\r\n    'Surface': makeReplacer(GML3.prototype.readSurface),\r\n    'MultiSurface': makeReplacer(GML3.prototype.readMultiSurface),\r\n    'Curve': makeReplacer(GML3.prototype.readCurve),\r\n    'MultiCurve': makeReplacer(GML3.prototype.readMultiCurve),\r\n    'Envelope': makeReplacer(GML3.prototype.readEnvelope),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML3.prototype.MULTICURVE_PARSERS = {\r\n  'http://www.opengis.net/gml': {\r\n    'curveMember': makeArrayPusher(GML3.prototype.curveMemberParser),\r\n    'curveMembers': makeArrayPusher(GML3.prototype.curveMemberParser),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML3.prototype.MULTISURFACE_PARSERS = {\r\n  'http://www.opengis.net/gml': {\r\n    'surfaceMember': makeArrayPusher(GML3.prototype.surfaceMemberParser),\r\n    'surfaceMembers': makeArrayPusher(GML3.prototype.surfaceMemberParser),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML3.prototype.CURVEMEMBER_PARSERS = {\r\n  'http://www.opengis.net/gml': {\r\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\r\n    'Curve': makeArrayPusher(GML3.prototype.readCurve),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML3.prototype.SURFACEMEMBER_PARSERS = {\r\n  'http://www.opengis.net/gml': {\r\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\r\n    'Surface': makeArrayPusher(GML3.prototype.readSurface),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML3.prototype.SURFACE_PARSERS = {\r\n  'http://www.opengis.net/gml': {\r\n    'patches': makeReplacer(GML3.prototype.readPatch),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML3.prototype.CURVE_PARSERS = {\r\n  'http://www.opengis.net/gml': {\r\n    'segments': makeReplacer(GML3.prototype.readSegment),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML3.prototype.ENVELOPE_PARSERS = {\r\n  'http://www.opengis.net/gml': {\r\n    'lowerCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\r\n    'upperCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML3.prototype.PATCHES_PARSERS = {\r\n  'http://www.opengis.net/gml': {\r\n    'PolygonPatch': makeReplacer(GML3.prototype.readPolygonPatch),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML3.prototype.SEGMENTS_PARSERS = {\r\n  'http://www.opengis.net/gml': {\r\n    'LineStringSegment': makeReplacer(GML3.prototype.readLineStringSegment),\r\n  },\r\n};\r\n\r\n/**\r\n * Encode an array of features in GML 3.1.1 Simple Features.\r\n *\r\n * @function\r\n * @param {Array<import(\"../Feature.js\").default>} features Features.\r\n * @param {import(\"./Feature.js\").WriteOptions=} opt_options Options.\r\n * @return {string} Result.\r\n * @api\r\n */\r\nGML3.prototype.writeFeatures;\r\n\r\n/**\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\nGML3.prototype.RING_SERIALIZERS = {\r\n  'http://www.opengis.net/gml': {\r\n    'exterior': makeChildAppender(GML3.prototype.writeRing),\r\n    'interior': makeChildAppender(GML3.prototype.writeRing),\r\n  },\r\n};\r\n\r\n/**\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\nGML3.prototype.ENVELOPE_SERIALIZERS = {\r\n  'http://www.opengis.net/gml': {\r\n    'lowerCorner': makeChildAppender(writeStringTextNode),\r\n    'upperCorner': makeChildAppender(writeStringTextNode),\r\n  },\r\n};\r\n\r\n/**\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\nGML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\r\n  'http://www.opengis.net/gml': {\r\n    'surfaceMember': makeChildAppender(\r\n      GML3.prototype.writeSurfaceOrPolygonMember\r\n    ),\r\n    'polygonMember': makeChildAppender(\r\n      GML3.prototype.writeSurfaceOrPolygonMember\r\n    ),\r\n  },\r\n};\r\n\r\n/**\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\nGML3.prototype.POINTMEMBER_SERIALIZERS = {\r\n  'http://www.opengis.net/gml': {\r\n    'pointMember': makeChildAppender(GML3.prototype.writePointMember),\r\n  },\r\n};\r\n\r\n/**\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\nGML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\r\n  'http://www.opengis.net/gml': {\r\n    'lineStringMember': makeChildAppender(\r\n      GML3.prototype.writeLineStringOrCurveMember\r\n    ),\r\n    'curveMember': makeChildAppender(\r\n      GML3.prototype.writeLineStringOrCurveMember\r\n    ),\r\n  },\r\n};\r\n\r\n/**\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\nGML3.prototype.GEOMETRY_SERIALIZERS = {\r\n  'http://www.opengis.net/gml': {\r\n    'Curve': makeChildAppender(GML3.prototype.writeCurveOrLineString),\r\n    'MultiCurve': makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),\r\n    'Point': makeChildAppender(GML3.prototype.writePoint),\r\n    'MultiPoint': makeChildAppender(GML3.prototype.writeMultiPoint),\r\n    'LineString': makeChildAppender(GML3.prototype.writeCurveOrLineString),\r\n    'MultiLineString': makeChildAppender(\r\n      GML3.prototype.writeMultiCurveOrLineString\r\n    ),\r\n    'LinearRing': makeChildAppender(GML3.prototype.writeLinearRing),\r\n    'Polygon': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\r\n    'MultiPolygon': makeChildAppender(\r\n      GML3.prototype.writeMultiSurfaceOrPolygon\r\n    ),\r\n    'Surface': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\r\n    'MultiSurface': makeChildAppender(\r\n      GML3.prototype.writeMultiSurfaceOrPolygon\r\n    ),\r\n    'Envelope': makeChildAppender(GML3.prototype.writeEnvelope),\r\n  },\r\n};\r\n\r\nexport default GML3;\r\n","/**\r\n * @module ol/format/GML32\r\n */\r\nimport GML2 from './GML2.js';\r\nimport GML3 from './GML3.js';\r\nimport GMLBase from './GMLBase.js';\r\nimport {makeArrayPusher, makeChildAppender, makeReplacer} from '../xml.js';\r\nimport {writeStringTextNode} from '../format/xsd.js';\r\n\r\n/**\r\n * @classdesc Feature format for reading and writing data in the GML format\r\n *            version 3.2.1.\r\n * @api\r\n */\r\nclass GML32 extends GML3 {\r\n  /**\r\n   * @param {import(\"./GMLBase.js\").Options=} opt_options Optional configuration object.\r\n   */\r\n  constructor(opt_options) {\r\n    const options = /** @type {import(\"./GMLBase.js\").Options} */ (opt_options\r\n      ? opt_options\r\n      : {});\r\n\r\n    super(options);\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    this.schemaLocation = options.schemaLocation\r\n      ? options.schemaLocation\r\n      : this.namespace + ' http://schemas.opengis.net/gml/3.2.1/gml.xsd';\r\n  }\r\n}\r\n\r\nGML32.prototype.namespace = 'http://www.opengis.net/gml/3.2';\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML32.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'pos': makeReplacer(GML3.prototype.readFlatPos),\r\n    'posList': makeReplacer(GML3.prototype.readFlatPosList),\r\n    'coordinates': makeReplacer(GML2.prototype.readFlatCoordinates),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML32.prototype.FLAT_LINEAR_RINGS_PARSERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'interior': GML3.prototype.interiorParser,\r\n    'exterior': GML3.prototype.exteriorParser,\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML32.prototype.GEOMETRY_PARSERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\r\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\r\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\r\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\r\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\r\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\r\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\r\n    'Surface': makeReplacer(GML32.prototype.readSurface),\r\n    'MultiSurface': makeReplacer(GML3.prototype.readMultiSurface),\r\n    'Curve': makeReplacer(GML32.prototype.readCurve),\r\n    'MultiCurve': makeReplacer(GML3.prototype.readMultiCurve),\r\n    'Envelope': makeReplacer(GML32.prototype.readEnvelope),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML32.prototype.MULTICURVE_PARSERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'curveMember': makeArrayPusher(GML3.prototype.curveMemberParser),\r\n    'curveMembers': makeArrayPusher(GML3.prototype.curveMemberParser),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML32.prototype.MULTISURFACE_PARSERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'surfaceMember': makeArrayPusher(GML3.prototype.surfaceMemberParser),\r\n    'surfaceMembers': makeArrayPusher(GML3.prototype.surfaceMemberParser),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML32.prototype.CURVEMEMBER_PARSERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\r\n    'Curve': makeArrayPusher(GML3.prototype.readCurve),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML32.prototype.SURFACEMEMBER_PARSERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\r\n    'Surface': makeArrayPusher(GML3.prototype.readSurface),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML32.prototype.SURFACE_PARSERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'patches': makeReplacer(GML3.prototype.readPatch),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML32.prototype.CURVE_PARSERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'segments': makeReplacer(GML3.prototype.readSegment),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML32.prototype.ENVELOPE_PARSERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'lowerCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\r\n    'upperCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML32.prototype.PATCHES_PARSERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'PolygonPatch': makeReplacer(GML3.prototype.readPolygonPatch),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML32.prototype.SEGMENTS_PARSERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'LineStringSegment': makeReplacer(GML3.prototype.readLineStringSegment),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML32.prototype.MULTIPOINT_PARSERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'pointMember': makeArrayPusher(GMLBase.prototype.pointMemberParser),\r\n    'pointMembers': makeArrayPusher(GMLBase.prototype.pointMemberParser),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML32.prototype.MULTILINESTRING_PARSERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'lineStringMember': makeArrayPusher(\r\n      GMLBase.prototype.lineStringMemberParser\r\n    ),\r\n    'lineStringMembers': makeArrayPusher(\r\n      GMLBase.prototype.lineStringMemberParser\r\n    ),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML32.prototype.MULTIPOLYGON_PARSERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'polygonMember': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\r\n    'polygonMembers': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML32.prototype.POINTMEMBER_PARSERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'Point': makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML32.prototype.LINESTRINGMEMBER_PARSERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML32.prototype.POLYGONMEMBER_PARSERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nGML32.prototype.RING_PARSERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing),\r\n  },\r\n};\r\n\r\n/**\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\nGML32.prototype.RING_SERIALIZERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'exterior': makeChildAppender(GML3.prototype.writeRing),\r\n    'interior': makeChildAppender(GML3.prototype.writeRing),\r\n  },\r\n};\r\n\r\n/**\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\nGML32.prototype.ENVELOPE_SERIALIZERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'lowerCorner': makeChildAppender(writeStringTextNode),\r\n    'upperCorner': makeChildAppender(writeStringTextNode),\r\n  },\r\n};\r\n\r\n/**\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\nGML32.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'surfaceMember': makeChildAppender(\r\n      GML3.prototype.writeSurfaceOrPolygonMember\r\n    ),\r\n    'polygonMember': makeChildAppender(\r\n      GML3.prototype.writeSurfaceOrPolygonMember\r\n    ),\r\n  },\r\n};\r\n\r\n/**\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\nGML32.prototype.POINTMEMBER_SERIALIZERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'pointMember': makeChildAppender(GML3.prototype.writePointMember),\r\n  },\r\n};\r\n\r\n/**\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\nGML32.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'lineStringMember': makeChildAppender(\r\n      GML3.prototype.writeLineStringOrCurveMember\r\n    ),\r\n    'curveMember': makeChildAppender(\r\n      GML3.prototype.writeLineStringOrCurveMember\r\n    ),\r\n  },\r\n};\r\n\r\n/**\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\nGML32.prototype.GEOMETRY_SERIALIZERS = {\r\n  'http://www.opengis.net/gml/3.2': {\r\n    'Curve': makeChildAppender(GML3.prototype.writeCurveOrLineString),\r\n    'MultiCurve': makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),\r\n    'Point': makeChildAppender(GML32.prototype.writePoint),\r\n    'MultiPoint': makeChildAppender(GML3.prototype.writeMultiPoint),\r\n    'LineString': makeChildAppender(GML3.prototype.writeCurveOrLineString),\r\n    'MultiLineString': makeChildAppender(\r\n      GML3.prototype.writeMultiCurveOrLineString\r\n    ),\r\n    'LinearRing': makeChildAppender(GML3.prototype.writeLinearRing),\r\n    'Polygon': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\r\n    'MultiPolygon': makeChildAppender(\r\n      GML3.prototype.writeMultiSurfaceOrPolygon\r\n    ),\r\n    'Surface': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\r\n    'MultiSurface': makeChildAppender(\r\n      GML3.prototype.writeMultiSurfaceOrPolygon\r\n    ),\r\n    'Envelope': makeChildAppender(GML3.prototype.writeEnvelope),\r\n  },\r\n};\r\n\r\nexport default GML32;\r\n","/**\r\n * @module ol/format/filter/Filter\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\r\n * Base class for WFS GetFeature filters.\r\n *\r\n * @abstract\r\n */\r\nclass Filter {\r\n  /**\r\n   * @param {!string} tagName The XML tag name for this filter.\r\n   */\r\n  constructor(tagName) {\r\n    /**\r\n     * @private\r\n     * @type {!string}\r\n     */\r\n    this.tagName_ = tagName;\r\n  }\r\n\r\n  /**\r\n   * The XML tag name for a filter.\r\n   * @returns {!string} Name.\r\n   */\r\n  getTagName() {\r\n    return this.tagName_;\r\n  }\r\n}\r\n\r\nexport default Filter;\r\n","/**\r\n * @module ol/format/filter/LogicalNary\r\n */\r\nimport Filter from './Filter.js';\r\nimport {assert} from '../../asserts.js';\r\n\r\n/**\r\n * @classdesc\r\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\r\n * Base class for WFS GetFeature n-ary logical filters.\r\n *\r\n * @abstract\r\n */\r\nclass LogicalNary extends Filter {\r\n  /**\r\n   * @param {!string} tagName The XML tag name for this filter.\r\n   * @param {Array<import(\"./Filter.js\").default>} conditions Conditions.\r\n   */\r\n  constructor(tagName, conditions) {\r\n    super(tagName);\r\n\r\n    /**\r\n     * @type {Array<import(\"./Filter.js\").default>}\r\n     */\r\n    this.conditions = conditions;\r\n    assert(this.conditions.length >= 2, 57); // At least 2 conditions are required.\r\n  }\r\n}\r\n\r\nexport default LogicalNary;\r\n","/**\r\n * @module ol/format/filter/And\r\n */\r\nimport LogicalNary from './LogicalNary.js';\r\n\r\n/**\r\n * @classdesc\r\n * Represents a logical `<And>` operator between two or more filter conditions.\r\n *\r\n * @abstract\r\n */\r\nclass And extends LogicalNary {\r\n  /**\r\n   * @param {...import(\"./Filter.js\").default} conditions Conditions.\r\n   */\r\n  constructor(conditions) {\r\n    super('And', Array.prototype.slice.call(arguments));\r\n  }\r\n}\r\n\r\nexport default And;\r\n","/**\r\n * @module ol/format/filter/Bbox\r\n */\r\nimport Filter from './Filter.js';\r\n\r\n/**\r\n * @classdesc\r\n * Represents a `<BBOX>` operator to test whether a geometry-valued property\r\n * intersects a fixed bounding box\r\n *\r\n * @api\r\n */\r\nclass Bbox extends Filter {\r\n  /**\r\n   * @param {!string} geometryName Geometry name to use.\r\n   * @param {!import(\"../../extent.js\").Extent} extent Extent.\r\n   * @param {string=} opt_srsName SRS name. No srsName attribute will be set\r\n   * on geometries when this is not provided.\r\n   */\r\n  constructor(geometryName, extent, opt_srsName) {\r\n    super('BBOX');\r\n\r\n    /**\r\n     * @type {!string}\r\n     */\r\n    this.geometryName = geometryName;\r\n\r\n    /**\r\n     * @type {import(\"../../extent.js\").Extent}\r\n     */\r\n    this.extent = extent;\r\n    if (extent.length !== 4) {\r\n      throw new Error(\r\n        'Expected an extent with four values ([minX, minY, maxX, maxY])'\r\n      );\r\n    }\r\n\r\n    /**\r\n     * @type {string|undefined}\r\n     */\r\n    this.srsName = opt_srsName;\r\n  }\r\n}\r\n\r\nexport default Bbox;\r\n","/**\r\n * @module ol/format/filter/Comparison\r\n */\r\nimport Filter from './Filter.js';\r\n\r\n/**\r\n * @classdesc\r\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\r\n * Base class for WFS GetFeature property comparison filters.\r\n *\r\n * @abstract\r\n */\r\nclass Comparison extends Filter {\r\n  /**\r\n   * @param {!string} tagName The XML tag name for this filter.\r\n   * @param {!string} propertyName Name of the context property to compare.\r\n   */\r\n  constructor(tagName, propertyName) {\r\n    super(tagName);\r\n\r\n    /**\r\n     * @type {!string}\r\n     */\r\n    this.propertyName = propertyName;\r\n  }\r\n}\r\n\r\nexport default Comparison;\r\n","/**\r\n * @module ol/format/filter/ComparisonBinary\r\n */\r\nimport Comparison from './Comparison.js';\r\n\r\n/**\r\n * @classdesc\r\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\r\n * Base class for WFS GetFeature property binary comparison filters.\r\n *\r\n * @abstract\r\n */\r\nclass ComparisonBinary extends Comparison {\r\n  /**\r\n   * @param {!string} tagName The XML tag name for this filter.\r\n   * @param {!string} propertyName Name of the context property to compare.\r\n   * @param {!(string|number)} expression The value to compare.\r\n   * @param {boolean=} opt_matchCase Case-sensitive?\r\n   */\r\n  constructor(tagName, propertyName, expression, opt_matchCase) {\r\n    super(tagName, propertyName);\r\n\r\n    /**\r\n     * @type {!(string|number)}\r\n     */\r\n    this.expression = expression;\r\n\r\n    /**\r\n     * @type {boolean|undefined}\r\n     */\r\n    this.matchCase = opt_matchCase;\r\n  }\r\n}\r\n\r\nexport default ComparisonBinary;\r\n","/**\r\n * @module ol/format/filter/EqualTo\r\n */\r\nimport ComparisonBinary from './ComparisonBinary.js';\r\n\r\n/**\r\n * @classdesc\r\n * Represents a `<PropertyIsEqualTo>` comparison operator.\r\n * @api\r\n */\r\nclass EqualTo extends ComparisonBinary {\r\n  /**\r\n   * @param {!string} propertyName Name of the context property to compare.\r\n   * @param {!(string|number)} expression The value to compare.\r\n   * @param {boolean=} opt_matchCase Case-sensitive?\r\n   */\r\n  constructor(propertyName, expression, opt_matchCase) {\r\n    super('PropertyIsEqualTo', propertyName, expression, opt_matchCase);\r\n  }\r\n}\r\n\r\nexport default EqualTo;\r\n","/**\r\n * @module ol/format/filter/IsLike\r\n */\r\nimport Comparison from './Comparison.js';\r\n\r\n/**\r\n * @classdesc\r\n * Represents a `<PropertyIsLike>` comparison operator.\r\n * @api\r\n */\r\nclass IsLike extends Comparison {\r\n  /**\r\n   * [constructor description]\r\n   * @param {!string} propertyName Name of the context property to compare.\r\n   * @param {!string} pattern Text pattern.\r\n   * @param {string=} opt_wildCard Pattern character which matches any sequence of\r\n   *    zero or more string characters. Default is '*'.\r\n   * @param {string=} opt_singleChar pattern character which matches any single\r\n   *    string character. Default is '.'.\r\n   * @param {string=} opt_escapeChar Escape character which can be used to escape\r\n   *    the pattern characters. Default is '!'.\r\n   * @param {boolean=} opt_matchCase Case-sensitive?\r\n   */\r\n  constructor(\r\n    propertyName,\r\n    pattern,\r\n    opt_wildCard,\r\n    opt_singleChar,\r\n    opt_escapeChar,\r\n    opt_matchCase\r\n  ) {\r\n    super('PropertyIsLike', propertyName);\r\n\r\n    /**\r\n     * @type {!string}\r\n     */\r\n    this.pattern = pattern;\r\n\r\n    /**\r\n     * @type {!string}\r\n     */\r\n    this.wildCard = opt_wildCard !== undefined ? opt_wildCard : '*';\r\n\r\n    /**\r\n     * @type {!string}\r\n     */\r\n    this.singleChar = opt_singleChar !== undefined ? opt_singleChar : '.';\r\n\r\n    /**\r\n     * @type {!string}\r\n     */\r\n    this.escapeChar = opt_escapeChar !== undefined ? opt_escapeChar : '!';\r\n\r\n    /**\r\n     * @type {boolean|undefined}\r\n     */\r\n    this.matchCase = opt_matchCase;\r\n  }\r\n}\r\n\r\nexport default IsLike;\r\n","/**\r\n * @module ol/format/filter\r\n */\r\nimport And from './filter/And.js';\r\nimport Bbox from './filter/Bbox.js';\r\nimport Contains from './filter/Contains.js';\r\nimport DWithin from './filter/DWithin.js';\r\nimport Disjoint from './filter/Disjoint.js';\r\nimport During from './filter/During.js';\r\nimport EqualTo from './filter/EqualTo.js';\r\nimport GreaterThan from './filter/GreaterThan.js';\r\nimport GreaterThanOrEqualTo from './filter/GreaterThanOrEqualTo.js';\r\nimport Intersects from './filter/Intersects.js';\r\nimport IsBetween from './filter/IsBetween.js';\r\nimport IsLike from './filter/IsLike.js';\r\nimport IsNull from './filter/IsNull.js';\r\nimport LessThan from './filter/LessThan.js';\r\nimport LessThanOrEqualTo from './filter/LessThanOrEqualTo.js';\r\nimport Not from './filter/Not.js';\r\nimport NotEqualTo from './filter/NotEqualTo.js';\r\nimport Or from './filter/Or.js';\r\nimport ResourceId from './filter/ResourceId.js';\r\nimport Within from './filter/Within.js';\r\n\r\n/**\r\n * Create a logical `<And>` operator between two or more filter conditions.\r\n *\r\n * @param {...import(\"./filter/Filter.js\").default} conditions Filter conditions.\r\n * @returns {!And} `<And>` operator.\r\n * @api\r\n */\r\nexport function and(conditions) {\r\n  const params = [null].concat(Array.prototype.slice.call(arguments));\r\n  return new (Function.prototype.bind.apply(And, params))();\r\n}\r\n\r\n/**\r\n * Create a logical `<Or>` operator between two or more filter conditions.\r\n *\r\n * @param {...import(\"./filter/Filter.js\").default} conditions Filter conditions.\r\n * @returns {!Or} `<Or>` operator.\r\n * @api\r\n */\r\nexport function or(conditions) {\r\n  const params = [null].concat(Array.prototype.slice.call(arguments));\r\n  return new (Function.prototype.bind.apply(Or, params))();\r\n}\r\n\r\n/**\r\n * Represents a logical `<Not>` operator for a filter condition.\r\n *\r\n * @param {!import(\"./filter/Filter.js\").default} condition Filter condition.\r\n * @returns {!Not} `<Not>` operator.\r\n * @api\r\n */\r\nexport function not(condition) {\r\n  return new Not(condition);\r\n}\r\n\r\n/**\r\n * Create a `<BBOX>` operator to test whether a geometry-valued property\r\n * intersects a fixed bounding box\r\n *\r\n * @param {!string} geometryName Geometry name to use.\r\n * @param {!import(\"../extent.js\").Extent} extent Extent.\r\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\r\n *    set on geometries when this is not provided.\r\n * @returns {!Bbox} `<BBOX>` operator.\r\n * @api\r\n */\r\nexport function bbox(geometryName, extent, opt_srsName) {\r\n  return new Bbox(geometryName, extent, opt_srsName);\r\n}\r\n\r\n/**\r\n * Create a `<Contains>` operator to test whether a geometry-valued property\r\n * contains a given geometry.\r\n *\r\n * @param {!string} geometryName Geometry name to use.\r\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\r\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\r\n *    set on geometries when this is not provided.\r\n * @returns {!Contains} `<Contains>` operator.\r\n * @api\r\n */\r\nexport function contains(geometryName, geometry, opt_srsName) {\r\n  return new Contains(geometryName, geometry, opt_srsName);\r\n}\r\n\r\n/**\r\n * Create a `<Intersects>` operator to test whether a geometry-valued property\r\n * intersects a given geometry.\r\n *\r\n * @param {!string} geometryName Geometry name to use.\r\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\r\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\r\n *    set on geometries when this is not provided.\r\n * @returns {!Intersects} `<Intersects>` operator.\r\n * @api\r\n */\r\nexport function intersects(geometryName, geometry, opt_srsName) {\r\n  return new Intersects(geometryName, geometry, opt_srsName);\r\n}\r\n\r\n/**\r\n * Create a `<Disjoint>` operator to test whether a geometry-valued property\r\n * is disjoint to a given geometry.\r\n *\r\n * @param {!string} geometryName Geometry name to use.\r\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\r\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\r\n *    set on geometries when this is not provided.\r\n * @returns {!Disjoint} `<Disjoint>` operator.\r\n * @api\r\n */\r\nexport function disjoint(geometryName, geometry, opt_srsName) {\r\n  return new Disjoint(geometryName, geometry, opt_srsName);\r\n}\r\n\r\n/**\r\n * Create a `<Within>` operator to test whether a geometry-valued property\r\n * is within a given geometry.\r\n *\r\n * @param {!string} geometryName Geometry name to use.\r\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\r\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\r\n *    set on geometries when this is not provided.\r\n * @returns {!Within} `<Within>` operator.\r\n * @api\r\n */\r\nexport function within(geometryName, geometry, opt_srsName) {\r\n  return new Within(geometryName, geometry, opt_srsName);\r\n}\r\n\r\n/**\r\n * Create a `<DWithin>` operator to test whether a geometry-valued property\r\n * is within a distance to a given geometry.\r\n *\r\n * @param {!string} geometryName Geometry name to use.\r\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\r\n * @param {!number} distance Distance.\r\n * @param {!string} unit Unit.\r\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\r\n *    set on geometries when this is not provided.\r\n * @returns {!DWithin} `<DWithin>` operator.\r\n * @api\r\n */\r\nexport function dwithin(geometryName, geometry, distance, unit, opt_srsName) {\r\n  return new DWithin(geometryName, geometry, distance, unit, opt_srsName);\r\n}\r\n\r\n/**\r\n * Creates a `<PropertyIsEqualTo>` comparison operator.\r\n *\r\n * @param {!string} propertyName Name of the context property to compare.\r\n * @param {!(string|number)} expression The value to compare.\r\n * @param {boolean=} opt_matchCase Case-sensitive?\r\n * @returns {!EqualTo} `<PropertyIsEqualTo>` operator.\r\n * @api\r\n */\r\nexport function equalTo(propertyName, expression, opt_matchCase) {\r\n  return new EqualTo(propertyName, expression, opt_matchCase);\r\n}\r\n\r\n/**\r\n * Creates a `<PropertyIsNotEqualTo>` comparison operator.\r\n *\r\n * @param {!string} propertyName Name of the context property to compare.\r\n * @param {!(string|number)} expression The value to compare.\r\n * @param {boolean=} opt_matchCase Case-sensitive?\r\n * @returns {!NotEqualTo} `<PropertyIsNotEqualTo>` operator.\r\n * @api\r\n */\r\nexport function notEqualTo(propertyName, expression, opt_matchCase) {\r\n  return new NotEqualTo(propertyName, expression, opt_matchCase);\r\n}\r\n\r\n/**\r\n * Creates a `<PropertyIsLessThan>` comparison operator.\r\n *\r\n * @param {!string} propertyName Name of the context property to compare.\r\n * @param {!number} expression The value to compare.\r\n * @returns {!LessThan} `<PropertyIsLessThan>` operator.\r\n * @api\r\n */\r\nexport function lessThan(propertyName, expression) {\r\n  return new LessThan(propertyName, expression);\r\n}\r\n\r\n/**\r\n * Creates a `<PropertyIsLessThanOrEqualTo>` comparison operator.\r\n *\r\n * @param {!string} propertyName Name of the context property to compare.\r\n * @param {!number} expression The value to compare.\r\n * @returns {!LessThanOrEqualTo} `<PropertyIsLessThanOrEqualTo>` operator.\r\n * @api\r\n */\r\nexport function lessThanOrEqualTo(propertyName, expression) {\r\n  return new LessThanOrEqualTo(propertyName, expression);\r\n}\r\n\r\n/**\r\n * Creates a `<PropertyIsGreaterThan>` comparison operator.\r\n *\r\n * @param {!string} propertyName Name of the context property to compare.\r\n * @param {!number} expression The value to compare.\r\n * @returns {!GreaterThan} `<PropertyIsGreaterThan>` operator.\r\n * @api\r\n */\r\nexport function greaterThan(propertyName, expression) {\r\n  return new GreaterThan(propertyName, expression);\r\n}\r\n\r\n/**\r\n * Creates a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.\r\n *\r\n * @param {!string} propertyName Name of the context property to compare.\r\n * @param {!number} expression The value to compare.\r\n * @returns {!GreaterThanOrEqualTo} `<PropertyIsGreaterThanOrEqualTo>` operator.\r\n * @api\r\n */\r\nexport function greaterThanOrEqualTo(propertyName, expression) {\r\n  return new GreaterThanOrEqualTo(propertyName, expression);\r\n}\r\n\r\n/**\r\n * Creates a `<PropertyIsNull>` comparison operator to test whether a property value\r\n * is null.\r\n *\r\n * @param {!string} propertyName Name of the context property to compare.\r\n * @returns {!IsNull} `<PropertyIsNull>` operator.\r\n * @api\r\n */\r\nexport function isNull(propertyName) {\r\n  return new IsNull(propertyName);\r\n}\r\n\r\n/**\r\n * Creates a `<PropertyIsBetween>` comparison operator to test whether an expression\r\n * value lies within a range given by a lower and upper bound (inclusive).\r\n *\r\n * @param {!string} propertyName Name of the context property to compare.\r\n * @param {!number} lowerBoundary The lower bound of the range.\r\n * @param {!number} upperBoundary The upper bound of the range.\r\n * @returns {!IsBetween} `<PropertyIsBetween>` operator.\r\n * @api\r\n */\r\nexport function between(propertyName, lowerBoundary, upperBoundary) {\r\n  return new IsBetween(propertyName, lowerBoundary, upperBoundary);\r\n}\r\n\r\n/**\r\n * Represents a `<PropertyIsLike>` comparison operator that matches a string property\r\n * value against a text pattern.\r\n *\r\n * @param {!string} propertyName Name of the context property to compare.\r\n * @param {!string} pattern Text pattern.\r\n * @param {string=} opt_wildCard Pattern character which matches any sequence of\r\n *    zero or more string characters. Default is '*'.\r\n * @param {string=} opt_singleChar pattern character which matches any single\r\n *    string character. Default is '.'.\r\n * @param {string=} opt_escapeChar Escape character which can be used to escape\r\n *    the pattern characters. Default is '!'.\r\n * @param {boolean=} opt_matchCase Case-sensitive?\r\n * @returns {!IsLike} `<PropertyIsLike>` operator.\r\n * @api\r\n */\r\nexport function like(\r\n  propertyName,\r\n  pattern,\r\n  opt_wildCard,\r\n  opt_singleChar,\r\n  opt_escapeChar,\r\n  opt_matchCase\r\n) {\r\n  return new IsLike(\r\n    propertyName,\r\n    pattern,\r\n    opt_wildCard,\r\n    opt_singleChar,\r\n    opt_escapeChar,\r\n    opt_matchCase\r\n  );\r\n}\r\n\r\n/**\r\n * Create a `<During>` temporal operator.\r\n *\r\n * @param {!string} propertyName Name of the context property to compare.\r\n * @param {!string} begin The begin date in ISO-8601 format.\r\n * @param {!string} end The end date in ISO-8601 format.\r\n * @returns {!During} `<During>` operator.\r\n * @api\r\n */\r\nexport function during(propertyName, begin, end) {\r\n  return new During(propertyName, begin, end);\r\n}\r\n\r\nexport function resourceId(rid) {\r\n  return new ResourceId(rid);\r\n}\r\n","/**\r\n * @module ol/format/WFS\r\n */\r\nimport GML2 from './GML2.js';\r\nimport GML3 from './GML3.js';\r\nimport GML32 from './GML32.js';\r\nimport GMLBase, {GMLNS} from './GMLBase.js';\r\nimport XMLFeature from './XMLFeature.js';\r\nimport {\r\n  XML_SCHEMA_INSTANCE_URI,\r\n  createElementNS,\r\n  isDocument,\r\n  makeArrayPusher,\r\n  makeChildAppender,\r\n  makeObjectPropertySetter,\r\n  makeSimpleNodeFactory,\r\n  parse,\r\n  parseNode,\r\n  pushParseAndPop,\r\n  pushSerializeAndPop,\r\n} from '../xml.js';\r\nimport {and as andFilterFn, bbox as bboxFilterFn} from './filter.js';\r\nimport {assert} from '../asserts.js';\r\nimport {assign} from '../obj.js';\r\nimport {get as getProjection} from '../proj.js';\r\nimport {\r\n  readNonNegativeInteger,\r\n  readNonNegativeIntegerString,\r\n  writeStringTextNode,\r\n} from './xsd.js';\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nconst FEATURE_COLLECTION_PARSERS = {\r\n  'http://www.opengis.net/gml': {\r\n    'boundedBy': makeObjectPropertySetter(\r\n      GMLBase.prototype.readGeometryElement,\r\n      'bounds'\r\n    ),\r\n  },\r\n  'http://www.opengis.net/wfs/2.0': {\r\n    'member': makeArrayPusher(GMLBase.prototype.readFeaturesInternal),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nconst TRANSACTION_SUMMARY_PARSERS = {\r\n  'http://www.opengis.net/wfs': {\r\n    'totalInserted': makeObjectPropertySetter(readNonNegativeInteger),\r\n    'totalUpdated': makeObjectPropertySetter(readNonNegativeInteger),\r\n    'totalDeleted': makeObjectPropertySetter(readNonNegativeInteger),\r\n  },\r\n  'http://www.opengis.net/wfs/2.0': {\r\n    'totalInserted': makeObjectPropertySetter(readNonNegativeInteger),\r\n    'totalUpdated': makeObjectPropertySetter(readNonNegativeInteger),\r\n    'totalDeleted': makeObjectPropertySetter(readNonNegativeInteger),\r\n  },\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nconst TRANSACTION_RESPONSE_PARSERS = {\r\n  'http://www.opengis.net/wfs': {\r\n    'TransactionSummary': makeObjectPropertySetter(\r\n      readTransactionSummary,\r\n      'transactionSummary'\r\n    ),\r\n    'InsertResults': makeObjectPropertySetter(readInsertResults, 'insertIds'),\r\n  },\r\n  'http://www.opengis.net/wfs/2.0': {\r\n    'TransactionSummary': makeObjectPropertySetter(\r\n      readTransactionSummary,\r\n      'transactionSummary'\r\n    ),\r\n    'InsertResults': makeObjectPropertySetter(readInsertResults, 'insertIds'),\r\n  },\r\n};\r\n\r\n/**\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\nconst QUERY_SERIALIZERS = {\r\n  'http://www.opengis.net/wfs': {\r\n    'PropertyName': makeChildAppender(writeStringTextNode),\r\n  },\r\n  'http://www.opengis.net/wfs/2.0': {\r\n    'PropertyName': makeChildAppender(writeStringTextNode),\r\n  },\r\n};\r\n\r\n/**\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\nconst TRANSACTION_SERIALIZERS = {\r\n  'http://www.opengis.net/wfs': {\r\n    'Insert': makeChildAppender(writeFeature),\r\n    'Update': makeChildAppender(writeUpdate),\r\n    'Delete': makeChildAppender(writeDelete),\r\n    'Property': makeChildAppender(writeProperty),\r\n    'Native': makeChildAppender(writeNative),\r\n  },\r\n  'http://www.opengis.net/wfs/2.0': {\r\n    'Insert': makeChildAppender(writeFeature),\r\n    'Update': makeChildAppender(writeUpdate),\r\n    'Delete': makeChildAppender(writeDelete),\r\n    'Property': makeChildAppender(writeProperty),\r\n    'Native': makeChildAppender(writeNative),\r\n  },\r\n};\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {Object<string, string>|string} [featureNS] The namespace URI used for features.\r\n * @property {Array<string>|string} [featureType] The feature type to parse. Only used for read operations.\r\n * @property {GMLBase} [gmlFormat] The GML format to use to parse the response.\r\n * Default is `ol/format/GML2` for WFS 1.0.0, `ol/format/GML3` for WFS 1.1.0 and `ol/format/GML32` for WFS 2.0.0.\r\n * @property {string} [schemaLocation] Optional schemaLocation to use for serialization, this will override the default.\r\n * @property {string} [version='1.1.0'] WFS version to use. Can be either `1.0.0`, `1.1.0` or `2.0.0`.\r\n */\r\n\r\n/**\r\n * @typedef {Object} WriteGetFeatureOptions\r\n * @property {string} featureNS The namespace URI used for features.\r\n * @property {string} featurePrefix The prefix for the feature namespace.\r\n * @property {Array<string|FeatureType>} featureTypes The feature type names or FeatureType objects to\r\n * define a unique bbox filter per feature type name (in this case, options `bbox` and `geometryName` are\r\n * ignored.).\r\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\r\n * geometries when this is not provided.\r\n * @property {string} [handle] Handle.\r\n * @property {string} [outputFormat] Output format.\r\n * @property {number} [maxFeatures] Maximum number of features to fetch.\r\n * @property {string} [geometryName] Geometry name to use in a BBOX filter.\r\n * @property {Array<string>} [propertyNames] Optional list of property names to serialize.\r\n * @property {string} [viewParams] viewParams GeoServer vendor parameter.\r\n * @property {number} [startIndex] Start index to use for WFS paging. This is a\r\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services.\r\n * @property {number} [count] Number of features to retrieve when paging. This is a\r\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services. Please note that some\r\n * Web Feature Services have repurposed `maxfeatures` instead.\r\n * @property {import(\"../extent.js\").Extent} [bbox] Extent to use for the BBOX filter. The `geometryName`\r\n * option must be set.\r\n * @property {import(\"./filter/Filter.js\").default} [filter] Filter condition. See\r\n * {@link module:ol/format/Filter} for more information.\r\n * @property {string} [resultType] Indicates what response should be returned,\r\n * E.g. `hits` only includes the `numberOfFeatures` attribute in the response and no features.\r\n */\r\n\r\n/**\r\n * @typedef {Object} FeatureType\r\n * @property {!string} name The feature type name.\r\n * @property {!import(\"../extent.js\").Extent} bbox Extent to use for the BBOX filter.\r\n * @property {!string} geometryName Geometry name to use in the BBOX filter.\r\n */\r\n\r\n/**\r\n * @typedef {Object} WriteTransactionOptions\r\n * @property {string} featureNS The namespace URI used for features.\r\n * @property {string} featurePrefix The prefix for the feature namespace.\r\n * @property {string} featureType The feature type name.\r\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\r\n * geometries when this is not provided.\r\n * @property {string} [handle] Handle.\r\n * @property {boolean} [hasZ] Must be set to true if the transaction is for\r\n * a 3D layer. This will allow the Z coordinate to be included in the transaction.\r\n * @property {Array<Object>} nativeElements Native elements. Currently not supported.\r\n * @property {import(\"./GMLBase.js\").Options} [gmlOptions] GML options for the WFS transaction writer.\r\n * @property {string} [version='1.1.0'] WFS version to use for the transaction. Can be either `1.0.0`, `1.1.0` or `2.0.0`.\r\n */\r\n\r\n/**\r\n * Number of features; bounds/extent.\r\n * @typedef {Object} FeatureCollectionMetadata\r\n * @property {number} numberOfFeatures\r\n * @property {import(\"../extent.js\").Extent} bounds\r\n */\r\n\r\n/**\r\n * Total deleted; total inserted; total updated; array of insert ids.\r\n * @typedef {Object} TransactionResponse\r\n * @property {number} totalDeleted\r\n * @property {number} totalInserted\r\n * @property {number} totalUpdated\r\n * @property {Array<string>} insertIds\r\n */\r\n\r\n/**\r\n * @type {string}\r\n */\r\nconst FEATURE_PREFIX = 'feature';\r\n\r\n/**\r\n * @type {string}\r\n */\r\nconst XMLNS = 'http://www.w3.org/2000/xmlns/';\r\n\r\n/**\r\n * @type {Object<string, string>}\r\n */\r\nconst OGCNS = {\r\n  '2.0.0': 'http://www.opengis.net/ogc/1.1',\r\n  '1.1.0': 'http://www.opengis.net/ogc',\r\n  '1.0.0': 'http://www.opengis.net/ogc',\r\n};\r\n\r\n/**\r\n * @type {Object<string, string>}\r\n */\r\nconst WFSNS = {\r\n  '2.0.0': 'http://www.opengis.net/wfs/2.0',\r\n  '1.1.0': 'http://www.opengis.net/wfs',\r\n  '1.0.0': 'http://www.opengis.net/wfs',\r\n};\r\n\r\n/**\r\n * @type {Object<string, string>}\r\n */\r\nconst FESNS = {\r\n  '2.0.0': 'http://www.opengis.net/fes/2.0',\r\n  '1.1.0': 'http://www.opengis.net/fes',\r\n  '1.0.0': 'http://www.opengis.net/fes',\r\n};\r\n\r\n/**\r\n * @type {Object<string, string>}\r\n */\r\nconst SCHEMA_LOCATIONS = {\r\n  '2.0.0':\r\n    'http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd',\r\n  '1.1.0':\r\n    'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd',\r\n  '1.0.0':\r\n    'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd',\r\n};\r\n\r\n/**\r\n * @type {Object<string, object>}\r\n */\r\nconst GML_FORMATS = {\r\n  '2.0.0': GML32,\r\n  '1.1.0': GML3,\r\n  '1.0.0': GML2,\r\n};\r\n\r\n/**\r\n * @const\r\n * @type {string}\r\n */\r\nconst DEFAULT_VERSION = '1.1.0';\r\n\r\n/**\r\n * @classdesc\r\n * Feature format for reading and writing data in the WFS format.\r\n * By default, supports WFS version 1.1.0. You can pass a GML format\r\n * as option to override the default.\r\n * Also see {@link module:ol/format/GMLBase~GMLBase} which is used by this format.\r\n *\r\n * @api\r\n */\r\nclass WFS extends XMLFeature {\r\n  /**\r\n   * @param {Options=} opt_options Optional configuration object.\r\n   */\r\n  constructor(opt_options) {\r\n    super();\r\n\r\n    const options = opt_options ? opt_options : {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.version_ = options.version ? options.version : DEFAULT_VERSION;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<string>|string|undefined}\r\n     */\r\n    this.featureType_ = options.featureType;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, string>|string|undefined}\r\n     */\r\n    this.featureNS_ = options.featureNS;\r\n\r\n    /**\r\n     * @private\r\n     * @type {GMLBase}\r\n     */\r\n    this.gmlFormat_ = options.gmlFormat\r\n      ? options.gmlFormat\r\n      : new GML_FORMATS[this.version_]();\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.schemaLocation_ = options.schemaLocation\r\n      ? options.schemaLocation\r\n      : SCHEMA_LOCATIONS[this.version_];\r\n  }\r\n\r\n  /**\r\n   * @return {Array<string>|string|undefined} featureType\r\n   */\r\n  getFeatureType() {\r\n    return this.featureType_;\r\n  }\r\n\r\n  /**\r\n   * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.\r\n   */\r\n  setFeatureType(featureType) {\r\n    this.featureType_ = featureType;\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {Element} node Node.\r\n   * @param {import(\"./Feature.js\").ReadOptions=} opt_options Options.\r\n   * @return {Array<import(\"../Feature.js\").default>} Features.\r\n   */\r\n  readFeaturesFromNode(node, opt_options) {\r\n    /** @type {import(\"../xml.js\").NodeStackItem} */\r\n    const context = {\r\n      node,\r\n    };\r\n    assign(context, {\r\n      'featureType': this.featureType_,\r\n      'featureNS': this.featureNS_,\r\n    });\r\n\r\n    assign(context, this.getReadOptions(node, opt_options ? opt_options : {}));\r\n    const objectStack = [context];\r\n    let featuresNS;\r\n    if (this.version_ === '2.0.0') {\r\n      featuresNS = FEATURE_COLLECTION_PARSERS;\r\n    } else {\r\n      featuresNS = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;\r\n    }\r\n    let features = pushParseAndPop(\r\n      [],\r\n      featuresNS,\r\n      node,\r\n      objectStack,\r\n      this.gmlFormat_\r\n    );\r\n    if (!features) {\r\n      features = [];\r\n    }\r\n    return features;\r\n  }\r\n\r\n  /**\r\n   * Read transaction response of the source.\r\n   *\r\n   * @param {Document|Element|Object|string} source Source.\r\n   * @return {TransactionResponse|undefined} Transaction response.\r\n   * @api\r\n   */\r\n  readTransactionResponse(source) {\r\n    if (!source) {\r\n      return undefined;\r\n    } else if (typeof source === 'string') {\r\n      const doc = parse(source);\r\n      return this.readTransactionResponseFromDocument(doc);\r\n    } else if (isDocument(source)) {\r\n      return this.readTransactionResponseFromDocument(\r\n        /** @type {Document} */ (source)\r\n      );\r\n    } else {\r\n      return this.readTransactionResponseFromNode(\r\n        /** @type {Element} */ (source)\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read feature collection metadata of the source.\r\n   *\r\n   * @param {Document|Element|Object|string} source Source.\r\n   * @return {FeatureCollectionMetadata|undefined}\r\n   *     FeatureCollection metadata.\r\n   * @api\r\n   */\r\n  readFeatureCollectionMetadata(source) {\r\n    if (!source) {\r\n      return undefined;\r\n    } else if (typeof source === 'string') {\r\n      const doc = parse(source);\r\n      return this.readFeatureCollectionMetadataFromDocument(doc);\r\n    } else if (isDocument(source)) {\r\n      return this.readFeatureCollectionMetadataFromDocument(\r\n        /** @type {Document} */ (source)\r\n      );\r\n    } else {\r\n      return this.readFeatureCollectionMetadataFromNode(\r\n        /** @type {Element} */ (source)\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Document} doc Document.\r\n   * @return {FeatureCollectionMetadata|undefined}\r\n   *     FeatureCollection metadata.\r\n   */\r\n  readFeatureCollectionMetadataFromDocument(doc) {\r\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\r\n      if (n.nodeType == Node.ELEMENT_NODE) {\r\n        return this.readFeatureCollectionMetadataFromNode(\r\n          /** @type {Element} */ (n)\r\n        );\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @return {FeatureCollectionMetadata|undefined}\r\n   *     FeatureCollection metadata.\r\n   */\r\n  readFeatureCollectionMetadataFromNode(node) {\r\n    const result = {};\r\n    const value = readNonNegativeIntegerString(\r\n      node.getAttribute('numberOfFeatures')\r\n    );\r\n    result['numberOfFeatures'] = value;\r\n    return pushParseAndPop(\r\n      /** @type {FeatureCollectionMetadata} */ (result),\r\n      FEATURE_COLLECTION_PARSERS,\r\n      node,\r\n      [],\r\n      this.gmlFormat_\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {Document} doc Document.\r\n   * @return {TransactionResponse|undefined} Transaction response.\r\n   */\r\n  readTransactionResponseFromDocument(doc) {\r\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\r\n      if (n.nodeType == Node.ELEMENT_NODE) {\r\n        return this.readTransactionResponseFromNode(/** @type {Element} */ (n));\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @return {TransactionResponse|undefined} Transaction response.\r\n   */\r\n  readTransactionResponseFromNode(node) {\r\n    return pushParseAndPop(\r\n      /** @type {TransactionResponse} */ ({}),\r\n      TRANSACTION_RESPONSE_PARSERS,\r\n      node,\r\n      []\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Encode format as WFS `GetFeature` and return the Node.\r\n   *\r\n   * @param {WriteGetFeatureOptions} options Options.\r\n   * @return {Node} Result.\r\n   * @api\r\n   */\r\n  writeGetFeature(options) {\r\n    const node = createElementNS(WFSNS[this.version_], 'GetFeature');\r\n    node.setAttribute('service', 'WFS');\r\n    node.setAttribute('version', this.version_);\r\n    if (options.handle) {\r\n      node.setAttribute('handle', options.handle);\r\n    }\r\n    if (options.outputFormat) {\r\n      node.setAttribute('outputFormat', options.outputFormat);\r\n    }\r\n    if (options.maxFeatures !== undefined) {\r\n      node.setAttribute('maxFeatures', String(options.maxFeatures));\r\n    }\r\n    if (options.resultType) {\r\n      node.setAttribute('resultType', options.resultType);\r\n    }\r\n    if (options.startIndex !== undefined) {\r\n      node.setAttribute('startIndex', String(options.startIndex));\r\n    }\r\n    if (options.count !== undefined) {\r\n      node.setAttribute('count', String(options.count));\r\n    }\r\n    if (options.viewParams !== undefined) {\r\n      node.setAttribute('viewParams', options.viewParams);\r\n    }\r\n    node.setAttributeNS(\r\n      XML_SCHEMA_INSTANCE_URI,\r\n      'xsi:schemaLocation',\r\n      this.schemaLocation_\r\n    );\r\n    /** @type {import(\"../xml.js\").NodeStackItem} */\r\n    const context = {\r\n      node,\r\n    };\r\n    assign(context, {\r\n      'version': this.version_,\r\n      'srsName': options.srsName,\r\n      'featureNS': options.featureNS ? options.featureNS : this.featureNS_,\r\n      'featurePrefix': options.featurePrefix,\r\n      'propertyNames': options.propertyNames ? options.propertyNames : [],\r\n    });\r\n    assert(Array.isArray(options.featureTypes), 11); // `options.featureTypes` must be an Array\r\n    if (typeof options.featureTypes[0] === 'string') {\r\n      let filter = options.filter;\r\n      if (options.bbox) {\r\n        assert(options.geometryName, 12); // `options.geometryName` must also be provided when `options.bbox` is set\r\n        filter = this.combineBboxAndFilter(\r\n          options.geometryName,\r\n          options.bbox,\r\n          options.srsName,\r\n          filter\r\n        );\r\n      }\r\n      assign(context, {\r\n        'geometryName': options.geometryName,\r\n        'filter': filter,\r\n      });\r\n      writeGetFeature(\r\n        node,\r\n        /** @type {!Array<string>} */ (options.featureTypes),\r\n        [context]\r\n      );\r\n    } else {\r\n      // Write one query node per element in featuresType.\r\n      options.featureTypes.forEach((/** @type {FeatureType} */ featureType) => {\r\n        const completeFilter = this.combineBboxAndFilter(\r\n          featureType.geometryName,\r\n          featureType.bbox,\r\n          options.srsName,\r\n          options.filter\r\n        );\r\n        assign(context, {\r\n          'geometryName': featureType.geometryName,\r\n          'filter': completeFilter,\r\n        });\r\n        writeGetFeature(node, [featureType.name], [context]);\r\n      });\r\n    }\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * Create a bbox filter and combine it with another optional filter.\r\n   *\r\n   * @param {!string} geometryName Geometry name to use.\r\n   * @param {!import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {string=} opt_srsName SRS name. No srsName attribute will be\r\n   *    set on geometries when this is not provided.\r\n   * @param {import(\"./filter/Filter.js\").default=} opt_filter Filter condition.\r\n   * @return {import(\"./filter/Filter.js\").default} The filter.\r\n   */\r\n  combineBboxAndFilter(geometryName, extent, opt_srsName, opt_filter) {\r\n    const bboxFilter = bboxFilterFn(geometryName, extent, opt_srsName);\r\n    if (opt_filter) {\r\n      // if bbox and filter are both set, combine the two into a single filter\r\n      return andFilterFn(opt_filter, bboxFilter);\r\n    }\r\n    return bboxFilter;\r\n  }\r\n\r\n  /**\r\n   * Encode format as WFS `Transaction` and return the Node.\r\n   *\r\n   * @param {Array<import(\"../Feature.js\").default>} inserts The features to insert.\r\n   * @param {Array<import(\"../Feature.js\").default>} updates The features to update.\r\n   * @param {Array<import(\"../Feature.js\").default>} deletes The features to delete.\r\n   * @param {WriteTransactionOptions} options Write options.\r\n   * @return {Node} Result.\r\n   * @api\r\n   */\r\n  writeTransaction(inserts, updates, deletes, options) {\r\n    const objectStack = [];\r\n    const version = options.version ? options.version : this.version_;\r\n    const node = createElementNS(WFSNS[version], 'Transaction');\r\n\r\n    node.setAttribute('service', 'WFS');\r\n    node.setAttribute('version', version);\r\n    let baseObj;\r\n    /** @type {import(\"../xml.js\").NodeStackItem} */\r\n    if (options) {\r\n      baseObj = options.gmlOptions ? options.gmlOptions : {};\r\n      if (options.handle) {\r\n        node.setAttribute('handle', options.handle);\r\n      }\r\n    }\r\n    node.setAttributeNS(\r\n      XML_SCHEMA_INSTANCE_URI,\r\n      'xsi:schemaLocation',\r\n      SCHEMA_LOCATIONS[version]\r\n    );\r\n\r\n    const request = createTransactionRequest(node, baseObj, version, options);\r\n    if (inserts) {\r\n      serializeTransactionRequest('Insert', inserts, objectStack, request);\r\n    }\r\n    if (updates) {\r\n      serializeTransactionRequest('Update', updates, objectStack, request);\r\n    }\r\n    if (deletes) {\r\n      serializeTransactionRequest('Delete', deletes, objectStack, request);\r\n    }\r\n    if (options.nativeElements) {\r\n      serializeTransactionRequest(\r\n        'Native',\r\n        options.nativeElements,\r\n        objectStack,\r\n        request\r\n      );\r\n    }\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * @param {Document} doc Document.\r\n   * @return {import(\"../proj/Projection.js\").default} Projection.\r\n   */\r\n  readProjectionFromDocument(doc) {\r\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\r\n      if (n.nodeType == Node.ELEMENT_NODE) {\r\n        return this.readProjectionFromNode(/** @type {Element} */ (n));\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @param {Element} node Node.\r\n   * @return {import(\"../proj/Projection.js\").default} Projection.\r\n   */\r\n  readProjectionFromNode(node) {\r\n    if (node.firstElementChild && node.firstElementChild.firstElementChild) {\r\n      node = node.firstElementChild.firstElementChild;\r\n      for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\r\n        if (\r\n          !(\r\n            n.childNodes.length === 0 ||\r\n            (n.childNodes.length === 1 && n.firstChild.nodeType === 3)\r\n          )\r\n        ) {\r\n          const objectStack = [{}];\r\n          this.gmlFormat_.readGeometryElement(n, objectStack);\r\n          return getProjection(objectStack.pop().srsName);\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {*} baseObj Base object.\r\n * @param {string} version Version.\r\n * @param {WriteTransactionOptions} options Options.\r\n * @return {Object} Request object.\r\n */\r\nfunction createTransactionRequest(node, baseObj, version, options) {\r\n  const featurePrefix = options.featurePrefix\r\n    ? options.featurePrefix\r\n    : FEATURE_PREFIX;\r\n  let gmlVersion;\r\n  if (version === '1.0.0') {\r\n    gmlVersion = 2;\r\n  } else if (version === '1.1.0') {\r\n    gmlVersion = 3;\r\n  } else if (version === '2.0.0') {\r\n    gmlVersion = 3.2;\r\n  }\r\n  const obj = assign(\r\n    {node},\r\n    {\r\n      version,\r\n      'featureNS': options.featureNS,\r\n      'featureType': options.featureType,\r\n      'featurePrefix': featurePrefix,\r\n      'gmlVersion': gmlVersion,\r\n      'hasZ': options.hasZ,\r\n      'srsName': options.srsName,\r\n    },\r\n    baseObj\r\n  );\r\n  return obj;\r\n}\r\n\r\n/**\r\n * @param {string} type Request type.\r\n * @param {Array<import(\"../Feature.js\").default>} features Features.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @param {Element} request Transaction Request.\r\n */\r\nfunction serializeTransactionRequest(type, features, objectStack, request) {\r\n  pushSerializeAndPop(\r\n    request,\r\n    TRANSACTION_SERIALIZERS,\r\n    makeSimpleNodeFactory(type),\r\n    features,\r\n    objectStack\r\n  );\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Object|undefined} Transaction Summary.\r\n */\r\nfunction readTransactionSummary(node, objectStack) {\r\n  return pushParseAndPop({}, TRANSACTION_SUMMARY_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nconst OGC_FID_PARSERS = {\r\n  'http://www.opengis.net/ogc': {\r\n    'FeatureId': makeArrayPusher(function (node, objectStack) {\r\n      return node.getAttribute('fid');\r\n    }),\r\n  },\r\n  'http://www.opengis.net/ogc/1.1': {\r\n    'FeatureId': makeArrayPusher(function (node, objectStack) {\r\n      return node.getAttribute('fid');\r\n    }),\r\n  },\r\n};\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n */\r\nfunction fidParser(node, objectStack) {\r\n  parseNode(OGC_FID_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @const\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\r\n */\r\nconst INSERT_RESULTS_PARSERS = {\r\n  'http://www.opengis.net/wfs': {\r\n    'Feature': fidParser,\r\n  },\r\n  'http://www.opengis.net/wfs/2.0': {\r\n    'Feature': fidParser,\r\n  },\r\n};\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {Array<*>} objectStack Object stack.\r\n * @return {Array<string>|undefined} Insert results.\r\n */\r\nfunction readInsertResults(node, objectStack) {\r\n  return pushParseAndPop([], INSERT_RESULTS_PARSERS, node, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {import(\"../Feature.js\").default} feature Feature.\r\n * @param {Array<*>} objectStack Node stack.\r\n */\r\nfunction writeFeature(node, feature, objectStack) {\r\n  const context = objectStack[objectStack.length - 1];\r\n  const featureType = context['featureType'];\r\n  const featureNS = context['featureNS'];\r\n  const gmlVersion = context['gmlVersion'];\r\n  const child = createElementNS(featureNS, featureType);\r\n  node.appendChild(child);\r\n  if (gmlVersion === 2) {\r\n    GML2.prototype.writeFeatureElement(child, feature, objectStack);\r\n  } else if (gmlVersion === 3) {\r\n    GML3.prototype.writeFeatureElement(child, feature, objectStack);\r\n  } else {\r\n    GML32.prototype.writeFeatureElement(child, feature, objectStack);\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @param {number|string} fid Feature identifier.\r\n * @param {Array<*>} objectStack Node stack.\r\n */\r\nfunction writeOgcFidFilter(node, fid, objectStack) {\r\n  const context = objectStack[objectStack.length - 1];\r\n  const version = context['version'];\r\n  const ns = OGCNS[version];\r\n  const filter = createElementNS(ns, 'Filter');\r\n  const child = createElementNS(ns, 'FeatureId');\r\n  filter.appendChild(child);\r\n  child.setAttribute('fid', /** @type {string} */ (fid));\r\n  node.appendChild(filter);\r\n}\r\n\r\n/**\r\n * @param {string|undefined} featurePrefix The prefix of the feature.\r\n * @param {string} featureType The type of the feature.\r\n * @returns {string} The value of the typeName property.\r\n */\r\nfunction getTypeName(featurePrefix, featureType) {\r\n  featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;\r\n  const prefix = featurePrefix + ':';\r\n  // The featureType already contains the prefix.\r\n  if (featureType.indexOf(prefix) === 0) {\r\n    return featureType;\r\n  } else {\r\n    return prefix + featureType;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {import(\"../Feature.js\").default} feature Feature.\r\n * @param {Array<*>} objectStack Node stack.\r\n */\r\nfunction writeDelete(node, feature, objectStack) {\r\n  const context = objectStack[objectStack.length - 1];\r\n  assert(feature.getId() !== undefined, 26); // Features must have an id set\r\n  const featureType = context['featureType'];\r\n  const featurePrefix = context['featurePrefix'];\r\n  const featureNS = context['featureNS'];\r\n  const typeName = getTypeName(featurePrefix, featureType);\r\n  node.setAttribute('typeName', typeName);\r\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\r\n  const fid = feature.getId();\r\n  if (fid !== undefined) {\r\n    writeOgcFidFilter(node, fid, objectStack);\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {import(\"../Feature.js\").default} feature Feature.\r\n * @param {Array<*>} objectStack Node stack.\r\n */\r\nfunction writeUpdate(node, feature, objectStack) {\r\n  const context = objectStack[objectStack.length - 1];\r\n  assert(feature.getId() !== undefined, 27); // Features must have an id set\r\n  const version = context['version'];\r\n  const featureType = context['featureType'];\r\n  const featurePrefix = context['featurePrefix'];\r\n  const featureNS = context['featureNS'];\r\n  const typeName = getTypeName(featurePrefix, featureType);\r\n  const geometryName = feature.getGeometryName();\r\n  node.setAttribute('typeName', typeName);\r\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\r\n  const fid = feature.getId();\r\n  if (fid !== undefined) {\r\n    const keys = feature.getKeys();\r\n    const values = [];\r\n    for (let i = 0, ii = keys.length; i < ii; i++) {\r\n      const value = feature.get(keys[i]);\r\n      if (value !== undefined) {\r\n        let name = keys[i];\r\n        if (\r\n          value &&\r\n          typeof (/** @type {?} */ (value).getSimplifiedGeometry) === 'function'\r\n        ) {\r\n          name = geometryName;\r\n        }\r\n        values.push({name: name, value: value});\r\n      }\r\n    }\r\n    pushSerializeAndPop(\r\n      /** @type {import(\"../xml.js\").NodeStackItem} */ ({\r\n        version,\r\n        'gmlVersion': context['gmlVersion'],\r\n        node,\r\n        'hasZ': context['hasZ'],\r\n        'srsName': context['srsName'],\r\n      }),\r\n      TRANSACTION_SERIALIZERS,\r\n      makeSimpleNodeFactory('Property'),\r\n      values,\r\n      objectStack\r\n    );\r\n    writeOgcFidFilter(node, fid, objectStack);\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @param {Object} pair Property name and value.\r\n * @param {Array<*>} objectStack Node stack.\r\n */\r\nfunction writeProperty(node, pair, objectStack) {\r\n  const context = objectStack[objectStack.length - 1];\r\n  const version = context['version'];\r\n  const ns = WFSNS[version];\r\n  const name = createElementNS(ns, 'Name');\r\n  const gmlVersion = context['gmlVersion'];\r\n  node.appendChild(name);\r\n  writeStringTextNode(name, pair.name);\r\n  if (pair.value !== undefined && pair.value !== null) {\r\n    const value = createElementNS(ns, 'Value');\r\n    node.appendChild(value);\r\n    if (\r\n      pair.value &&\r\n      typeof (/** @type {?} */ (pair.value).getSimplifiedGeometry) ===\r\n        'function'\r\n    ) {\r\n      if (gmlVersion === 2) {\r\n        GML2.prototype.writeGeometryElement(value, pair.value, objectStack);\r\n      } else if (gmlVersion === 3) {\r\n        GML3.prototype.writeGeometryElement(value, pair.value, objectStack);\r\n      } else {\r\n        GML32.prototype.writeGeometryElement(value, pair.value, objectStack);\r\n      }\r\n    } else {\r\n      writeStringTextNode(value, pair.value);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {{vendorId: string, safeToIgnore: boolean, value: string}} nativeElement The native element.\r\n * @param {Array<*>} objectStack Node stack.\r\n */\r\nfunction writeNative(node, nativeElement, objectStack) {\r\n  if (nativeElement.vendorId) {\r\n    node.setAttribute('vendorId', nativeElement.vendorId);\r\n  }\r\n  if (nativeElement.safeToIgnore !== undefined) {\r\n    node.setAttribute('safeToIgnore', String(nativeElement.safeToIgnore));\r\n  }\r\n  if (nativeElement.value !== undefined) {\r\n    writeStringTextNode(node, nativeElement.value);\r\n  }\r\n}\r\n\r\n/**\r\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\r\n */\r\nconst GETFEATURE_SERIALIZERS = {\r\n  'http://www.opengis.net/wfs': {\r\n    'Query': makeChildAppender(writeQuery),\r\n  },\r\n  'http://www.opengis.net/wfs/2.0': {\r\n    'Query': makeChildAppender(writeQuery),\r\n  },\r\n  'http://www.opengis.net/ogc': {\r\n    'During': makeChildAppender(writeDuringFilter),\r\n    'And': makeChildAppender(writeLogicalFilter),\r\n    'Or': makeChildAppender(writeLogicalFilter),\r\n    'Not': makeChildAppender(writeNotFilter),\r\n    'BBOX': makeChildAppender(writeBboxFilter),\r\n    'Contains': makeChildAppender(writeSpatialFilter),\r\n    'Intersects': makeChildAppender(writeSpatialFilter),\r\n    'Within': makeChildAppender(writeSpatialFilter),\r\n    'DWithin': makeChildAppender(writeDWithinFilter),\r\n    'PropertyIsEqualTo': makeChildAppender(writeComparisonFilter),\r\n    'PropertyIsNotEqualTo': makeChildAppender(writeComparisonFilter),\r\n    'PropertyIsLessThan': makeChildAppender(writeComparisonFilter),\r\n    'PropertyIsLessThanOrEqualTo': makeChildAppender(writeComparisonFilter),\r\n    'PropertyIsGreaterThan': makeChildAppender(writeComparisonFilter),\r\n    'PropertyIsGreaterThanOrEqualTo': makeChildAppender(writeComparisonFilter),\r\n    'PropertyIsNull': makeChildAppender(writeIsNullFilter),\r\n    'PropertyIsBetween': makeChildAppender(writeIsBetweenFilter),\r\n    'PropertyIsLike': makeChildAppender(writeIsLikeFilter),\r\n  },\r\n  'http://www.opengis.net/fes/2.0': {\r\n    'During': makeChildAppender(writeDuringFilter),\r\n    'And': makeChildAppender(writeLogicalFilter),\r\n    'Or': makeChildAppender(writeLogicalFilter),\r\n    'Not': makeChildAppender(writeNotFilter),\r\n    'BBOX': makeChildAppender(writeBboxFilter),\r\n    'Contains': makeChildAppender(writeSpatialFilter),\r\n    'Disjoint': makeChildAppender(writeSpatialFilter),\r\n    'Intersects': makeChildAppender(writeSpatialFilter),\r\n    'ResourceId': makeChildAppender(writeResourceIdFilter),\r\n    'Within': makeChildAppender(writeSpatialFilter),\r\n    'DWithin': makeChildAppender(writeDWithinFilter),\r\n    'PropertyIsEqualTo': makeChildAppender(writeComparisonFilter),\r\n    'PropertyIsNotEqualTo': makeChildAppender(writeComparisonFilter),\r\n    'PropertyIsLessThan': makeChildAppender(writeComparisonFilter),\r\n    'PropertyIsLessThanOrEqualTo': makeChildAppender(writeComparisonFilter),\r\n    'PropertyIsGreaterThan': makeChildAppender(writeComparisonFilter),\r\n    'PropertyIsGreaterThanOrEqualTo': makeChildAppender(writeComparisonFilter),\r\n    'PropertyIsNull': makeChildAppender(writeIsNullFilter),\r\n    'PropertyIsBetween': makeChildAppender(writeIsBetweenFilter),\r\n    'PropertyIsLike': makeChildAppender(writeIsLikeFilter),\r\n  },\r\n};\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {string} featureType Feature type.\r\n * @param {Array<*>} objectStack Node stack.\r\n */\r\nfunction writeQuery(node, featureType, objectStack) {\r\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\r\n  const version = context['version'];\r\n  const featurePrefix = context['featurePrefix'];\r\n  const featureNS = context['featureNS'];\r\n  const propertyNames = context['propertyNames'];\r\n  const srsName = context['srsName'];\r\n  let typeName;\r\n  // If feature prefix is not defined, we must not use the default prefix.\r\n  if (featurePrefix) {\r\n    typeName = getTypeName(featurePrefix, featureType);\r\n  } else {\r\n    typeName = featureType;\r\n  }\r\n  let typeNameAttr;\r\n  if (version === '2.0.0') {\r\n    typeNameAttr = 'typeNames';\r\n  } else {\r\n    typeNameAttr = 'typeName';\r\n  }\r\n  node.setAttribute(typeNameAttr, typeName);\r\n  if (srsName) {\r\n    node.setAttribute('srsName', srsName);\r\n  }\r\n  if (featureNS) {\r\n    node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\r\n  }\r\n  const item = /** @type {import(\"../xml.js\").NodeStackItem} */ (assign(\r\n    {},\r\n    context\r\n  ));\r\n  item.node = node;\r\n  pushSerializeAndPop(\r\n    item,\r\n    QUERY_SERIALIZERS,\r\n    makeSimpleNodeFactory('PropertyName'),\r\n    propertyNames,\r\n    objectStack\r\n  );\r\n  const filter = context['filter'];\r\n  if (filter) {\r\n    const child = createElementNS(getFilterNS(version), 'Filter');\r\n    node.appendChild(child);\r\n    writeFilterCondition(child, filter, objectStack);\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @param {import(\"./filter/Filter.js\").default} filter Filter.\r\n * @param {Array<*>} objectStack Node stack.\r\n */\r\nfunction writeFilterCondition(node, filter, objectStack) {\r\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\r\n  /** @type {import(\"../xml.js\").NodeStackItem} */\r\n  const item = {node};\r\n  assign(item, {context});\r\n  pushSerializeAndPop(\r\n    item,\r\n    GETFEATURE_SERIALIZERS,\r\n    makeSimpleNodeFactory(filter.getTagName()),\r\n    [filter],\r\n    objectStack\r\n  );\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @param {import(\"./filter/Bbox.js\").default} filter Filter.\r\n * @param {Array<*>} objectStack Node stack.\r\n */\r\nfunction writeBboxFilter(node, filter, objectStack) {\r\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\r\n  const context = parent['context'];\r\n  const version = context['version'];\r\n  parent['srsName'] = filter.srsName;\r\n  const format = GML_FORMATS[version];\r\n\r\n  writePropertyName(version, node, filter.geometryName);\r\n  format.prototype.writeGeometryElement(node, filter.extent, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Element} node Element.\r\n * @param {import(\"./filter/ResourceId.js\").default} filter Filter.\r\n * @param {Array<*>} objectStack Node stack.\r\n */\r\nfunction writeResourceIdFilter(node, filter, objectStack) {\r\n  node.setAttribute('rid', /** @type {string} */ (filter.rid));\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @param {import(\"./filter/Spatial.js\").default} filter Filter.\r\n * @param {Array<*>} objectStack Node stack.\r\n */\r\nfunction writeSpatialFilter(node, filter, objectStack) {\r\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\r\n  const context = parent['context'];\r\n  const version = context['version'];\r\n  parent['srsName'] = filter.srsName;\r\n  const format = GML_FORMATS[version];\r\n\r\n  writePropertyName(version, node, filter.geometryName);\r\n  format.prototype.writeGeometryElement(node, filter.geometry, objectStack);\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @param {import(\"./filter/DWithin.js\").default} filter Filter.\r\n * @param {Array<*>} objectStack Node stack.\r\n */\r\nfunction writeDWithinFilter(node, filter, objectStack) {\r\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\r\n  const context = parent['context'];\r\n  const version = context['version'];\r\n  writeSpatialFilter(node, filter, objectStack);\r\n  const distance = createElementNS(getFilterNS(version), 'Distance');\r\n  writeStringTextNode(distance, filter.distance.toString());\r\n  if (version === '2.0.0') {\r\n    distance.setAttribute('uom', filter.unit);\r\n  } else {\r\n    distance.setAttribute('units', filter.unit);\r\n  }\r\n  node.appendChild(distance);\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @param {import(\"./filter/During.js\").default} filter Filter.\r\n * @param {Array<*>} objectStack Node stack.\r\n */\r\nfunction writeDuringFilter(node, filter, objectStack) {\r\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\r\n  const context = parent['context'];\r\n  const version = context['version'];\r\n\r\n  writeExpression(FESNS[version], 'ValueReference', node, filter.propertyName);\r\n  const timePeriod = createElementNS(GMLNS, 'TimePeriod');\r\n\r\n  node.appendChild(timePeriod);\r\n\r\n  const begin = createElementNS(GMLNS, 'begin');\r\n  timePeriod.appendChild(begin);\r\n  writeTimeInstant(begin, filter.begin);\r\n\r\n  const end = createElementNS(GMLNS, 'end');\r\n  timePeriod.appendChild(end);\r\n  writeTimeInstant(end, filter.end);\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @param {import(\"./filter/LogicalNary.js\").default} filter Filter.\r\n * @param {Array<*>} objectStack Node stack.\r\n */\r\nfunction writeLogicalFilter(node, filter, objectStack) {\r\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\r\n  const context = parent['context'];\r\n  /** @type {import(\"../xml.js\").NodeStackItem} */\r\n  const item = {node};\r\n  assign(item, {context});\r\n  const conditions = filter.conditions;\r\n  for (let i = 0, ii = conditions.length; i < ii; ++i) {\r\n    const condition = conditions[i];\r\n    pushSerializeAndPop(\r\n      item,\r\n      GETFEATURE_SERIALIZERS,\r\n      makeSimpleNodeFactory(condition.getTagName()),\r\n      [condition],\r\n      objectStack\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @param {import(\"./filter/Not.js\").default} filter Filter.\r\n * @param {Array<*>} objectStack Node stack.\r\n */\r\nfunction writeNotFilter(node, filter, objectStack) {\r\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\r\n  const context = parent['context'];\r\n  /** @type {import(\"../xml.js\").NodeStackItem} */\r\n  const item = {node};\r\n  assign(item, {context});\r\n  const condition = filter.condition;\r\n  pushSerializeAndPop(\r\n    item,\r\n    GETFEATURE_SERIALIZERS,\r\n    makeSimpleNodeFactory(condition.getTagName()),\r\n    [condition],\r\n    objectStack\r\n  );\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {import(\"./filter/ComparisonBinary.js\").default} filter Filter.\r\n * @param {Array<*>} objectStack Node stack.\r\n */\r\nfunction writeComparisonFilter(node, filter, objectStack) {\r\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\r\n  const context = parent['context'];\r\n  const version = context['version'];\r\n  if (filter.matchCase !== undefined) {\r\n    node.setAttribute('matchCase', filter.matchCase.toString());\r\n  }\r\n  writePropertyName(version, node, filter.propertyName);\r\n  writeLiteral(version, node, '' + filter.expression);\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @param {import(\"./filter/IsNull.js\").default} filter Filter.\r\n * @param {Array<*>} objectStack Node stack.\r\n */\r\nfunction writeIsNullFilter(node, filter, objectStack) {\r\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\r\n  const context = parent['context'];\r\n  const version = context['version'];\r\n  writePropertyName(version, node, filter.propertyName);\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @param {import(\"./filter/IsBetween.js\").default} filter Filter.\r\n * @param {Array<*>} objectStack Node stack.\r\n */\r\nfunction writeIsBetweenFilter(node, filter, objectStack) {\r\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\r\n  const context = parent['context'];\r\n  const version = context['version'];\r\n  const ns = getFilterNS(version);\r\n\r\n  writePropertyName(version, node, filter.propertyName);\r\n\r\n  const lowerBoundary = createElementNS(ns, 'LowerBoundary');\r\n  node.appendChild(lowerBoundary);\r\n  writeLiteral(version, lowerBoundary, '' + filter.lowerBoundary);\r\n\r\n  const upperBoundary = createElementNS(ns, 'UpperBoundary');\r\n  node.appendChild(upperBoundary);\r\n  writeLiteral(version, upperBoundary, '' + filter.upperBoundary);\r\n}\r\n\r\n/**\r\n * @param {Element} node Node.\r\n * @param {import(\"./filter/IsLike.js\").default} filter Filter.\r\n * @param {Array<*>} objectStack Node stack.\r\n */\r\nfunction writeIsLikeFilter(node, filter, objectStack) {\r\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\r\n  const context = parent['context'];\r\n  const version = context['version'];\r\n  node.setAttribute('wildCard', filter.wildCard);\r\n  node.setAttribute('singleChar', filter.singleChar);\r\n  node.setAttribute('escapeChar', filter.escapeChar);\r\n  if (filter.matchCase !== undefined) {\r\n    node.setAttribute('matchCase', filter.matchCase.toString());\r\n  }\r\n  writePropertyName(version, node, filter.propertyName);\r\n  writeLiteral(version, node, '' + filter.pattern);\r\n}\r\n\r\n/**\r\n * @param {string} ns Namespace.\r\n * @param {string} tagName Tag name.\r\n * @param {Node} node Node.\r\n * @param {string} value Value.\r\n */\r\nfunction writeExpression(ns, tagName, node, value) {\r\n  const property = createElementNS(ns, tagName);\r\n  writeStringTextNode(property, value);\r\n  node.appendChild(property);\r\n}\r\n\r\n/**\r\n * @param {string} version Version.\r\n * @param {Node} node Node.\r\n * @param {string} value PropertyName value.\r\n */\r\nfunction writeLiteral(version, node, value) {\r\n  writeExpression(getFilterNS(version), 'Literal', node, value);\r\n}\r\n\r\n/**\r\n * @param {string} version Version.\r\n * @param {Node} node Node.\r\n * @param {string} value PropertyName value.\r\n */\r\nfunction writePropertyName(version, node, value) {\r\n  if (version === '2.0.0') {\r\n    writeExpression(FESNS[version], 'ValueReference', node, value);\r\n  } else {\r\n    writeExpression(OGCNS[version], 'PropertyName', node, value);\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @param {string} time PropertyName value.\r\n */\r\nfunction writeTimeInstant(node, time) {\r\n  const timeInstant = createElementNS(GMLNS, 'TimeInstant');\r\n  node.appendChild(timeInstant);\r\n\r\n  const timePosition = createElementNS(GMLNS, 'timePosition');\r\n  timeInstant.appendChild(timePosition);\r\n  writeStringTextNode(timePosition, time);\r\n}\r\n\r\n/**\r\n * Encode filter as WFS `Filter` and return the Node.\r\n *\r\n * @param {import(\"./filter/Filter.js\").default} filter Filter.\r\n * @param {string} version Version.\r\n * @return {Node} Result.\r\n * @api\r\n */\r\nexport function writeFilter(filter, version) {\r\n  const child = createElementNS(OGCNS[version], 'Filter');\r\n  const context = {\r\n    node: child,\r\n  };\r\n  assign(context, {\r\n    'version': version,\r\n    'filter': filter,\r\n  });\r\n  writeFilterCondition(child, filter, [context]);\r\n  return child;\r\n}\r\n\r\n/**\r\n * @param {Node} node Node.\r\n * @param {Array<string>} featureTypes Feature types.\r\n * @param {Array<*>} objectStack Node stack.\r\n */\r\nfunction writeGetFeature(node, featureTypes, objectStack) {\r\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\r\n  const item = /** @type {import(\"../xml.js\").NodeStackItem} */ (assign(\r\n    {},\r\n    context\r\n  ));\r\n  item.node = node;\r\n  pushSerializeAndPop(\r\n    item,\r\n    GETFEATURE_SERIALIZERS,\r\n    makeSimpleNodeFactory('Query'),\r\n    featureTypes,\r\n    objectStack\r\n  );\r\n}\r\n\r\nfunction getFilterNS(version) {\r\n  let ns;\r\n  if (version === '2.0.0') {\r\n    ns = FESNS[version];\r\n  } else {\r\n    ns = OGCNS[version];\r\n  }\r\n  return ns;\r\n}\r\n\r\nexport default WFS;\r\n","import Map from '../src/ol/Map.js';\r\nimport VectorSource from '../src/ol/source/Vector.js';\r\nimport View from '../src/ol/View.js';\r\nimport XYZ from '../src/ol/source/XYZ.js';\r\nimport {GeoJSON, WFS} from '../src/ol/format.js';\r\nimport {Stroke, Style} from '../src/ol/style.js';\r\nimport {Tile as TileLayer, Vector as VectorLayer} from '../src/ol/layer.js';\r\nimport {\r\n  and as andFilter,\r\n  equalTo as equalToFilter,\r\n  like as likeFilter,\r\n} from '../src/ol/format/filter.js';\r\n\r\nconst vectorSource = new VectorSource();\r\nconst vector = new VectorLayer({\r\n  source: vectorSource,\r\n  style: new Style({\r\n    stroke: new Stroke({\r\n      color: 'rgba(0, 0, 255, 1.0)',\r\n      width: 2,\r\n    }),\r\n  }),\r\n});\r\n\r\nconst key = 'get_your_own_D6rA4zTHduk6KOKTXzGB';\r\nconst attributions =\r\n  '<a href=\"https://www.maptiler.com/copyright/\" target=\"_blank\">&copy; MapTiler</a> ' +\r\n  '<a href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\">&copy; OpenStreetMap contributors</a>';\r\n\r\nconst raster = new TileLayer({\r\n  source: new XYZ({\r\n    attributions: attributions,\r\n    url: 'https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=' + key,\r\n    maxZoom: 20,\r\n  }),\r\n});\r\n\r\nconst map = new Map({\r\n  layers: [raster, vector],\r\n  target: document.getElementById('map'),\r\n  view: new View({\r\n    center: [-8908887.277395891, 5381918.072437216],\r\n    maxZoom: 19,\r\n    zoom: 12,\r\n  }),\r\n});\r\n\r\n// generate a GetFeature request\r\nconst featureRequest = new WFS().writeGetFeature({\r\n  srsName: 'EPSG:3857',\r\n  featureNS: 'http://openstreemap.org',\r\n  featurePrefix: 'osm',\r\n  featureTypes: ['water_areas'],\r\n  outputFormat: 'application/json',\r\n  filter: andFilter(\r\n    likeFilter('name', 'Mississippi*'),\r\n    equalToFilter('waterway', 'riverbank')\r\n  ),\r\n});\r\n\r\n// then post the request and add the received features to a layer\r\nfetch('https://ahocevar.com/geoserver/wfs', {\r\n  method: 'POST',\r\n  body: new XMLSerializer().serializeToString(featureRequest),\r\n})\r\n  .then(function (response) {\r\n    return response.json();\r\n  })\r\n  .then(function (json) {\r\n    const features = new GeoJSON().readFeatures(json);\r\n    vectorSource.addFeatures(features);\r\n    map.getView().fit(vectorSource.getExtent());\r\n  });\r\n"],"sourceRoot":""}