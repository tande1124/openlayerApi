{"version":3,"sources":["webpack:///./geolocation-orientation.js"],"names":["view","center","zoom","tileLayer","source","map","layers","target","markerEl","document","getElementById","marker","positioning","element","stopEvent","addOverlay","const","positions","geolocation","projection","getProjection","trackingOptions","maximumAge","enableHighAccuracy","timeout","deltaMean","on","position","getPosition","accuracy","getAccuracy","heading","getHeading","speed","getSpeed","m","x","y","fCoords","getCoordinates","previous","length","prevHeading","let","headingDiff","Math","PI","abs","appendCoordinate","setCoordinates","slice","src","addPosition","Date","now","coords","len","rad","html","toFixed","round","join","innerHTML","alert","previousM","updateView","max","rotation","resolution","height","c","getCoordinateAtM","setCenter","getResolution","getSize","sin","cos","setRotation","setPosition","render","simulationData","geolocateBtn","addEventListener","setTracking","disableButtons","client","XMLHttpRequest","open","onload","JSON","parse","responseText","data","send","simulateBtn","simulatePositionChange","set","projectedPosition","longitude","latitude","changed","disabled","coordinates","first","shift","prevDate","timestamp","geolocate","newDate","window","setTimeout"],"mappings":"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","file":"geolocation-orientation.js","sourcesContent":["import Geolocation from '../src/ol/Geolocation.js';\r\nimport LineString from '../src/ol/geom/LineString.js';\r\nimport Map from '../src/ol/Map.js';\r\nimport OSM from '../src/ol/source/OSM.js';\r\nimport Overlay from '../src/ol/Overlay.js';\r\nimport TileLayer from '../src/ol/layer/Tile.js';\r\nimport View from '../src/ol/View.js';\r\nimport {fromLonLat} from '../src/ol/proj.js';\r\n\r\n// creating the view\r\nconst view = new View({\r\n  center: fromLonLat([5.8713, 45.6452]),\r\n  zoom: 19,\r\n});\r\n\r\nconst tileLayer = new TileLayer({\r\n  source: new OSM(),\r\n});\r\n\r\n// creating the map\r\nconst map = new Map({\r\n  layers: [tileLayer],\r\n  target: 'map',\r\n  view: view,\r\n});\r\n\r\n// Geolocation marker\r\nconst markerEl = document.getElementById('geolocation_marker');\r\nconst marker = new Overlay({\r\n  positioning: 'center-center',\r\n  element: markerEl,\r\n  stopEvent: false,\r\n});\r\nmap.addOverlay(marker);\r\n\r\n// LineString to store the different geolocation positions. This LineString\r\n// is time aware.\r\n// The Z dimension is actually used to store the rotation (heading).\r\nconst positions = new LineString([], 'XYZM');\r\n\r\n// Geolocation Control\r\nconst geolocation = new Geolocation({\r\n  projection: view.getProjection(),\r\n  trackingOptions: {\r\n    maximumAge: 10000,\r\n    enableHighAccuracy: true,\r\n    timeout: 600000,\r\n  },\r\n});\r\n\r\nlet deltaMean = 500; // the geolocation sampling period mean in ms\r\n\r\n// Listen to position changes\r\ngeolocation.on('change', function () {\r\n  const position = geolocation.getPosition();\r\n  const accuracy = geolocation.getAccuracy();\r\n  const heading = geolocation.getHeading() || 0;\r\n  const speed = geolocation.getSpeed() || 0;\r\n  const m = Date.now();\r\n\r\n  addPosition(position, heading, m, speed);\r\n\r\n  const coords = positions.getCoordinates();\r\n  const len = coords.length;\r\n  if (len >= 2) {\r\n    deltaMean = (coords[len - 1][3] - coords[0][3]) / (len - 1);\r\n  }\r\n\r\n  const html = [\r\n    'Position: ' + position[0].toFixed(2) + ', ' + position[1].toFixed(2),\r\n    'Accuracy: ' + accuracy,\r\n    'Heading: ' + Math.round(radToDeg(heading)) + '&deg;',\r\n    'Speed: ' + (speed * 3.6).toFixed(1) + ' km/h',\r\n    'Delta: ' + Math.round(deltaMean) + 'ms',\r\n  ].join('<br />');\r\n  document.getElementById('info').innerHTML = html;\r\n});\r\n\r\ngeolocation.on('error', function () {\r\n  alert('geolocation error');\r\n  // FIXME we should remove the coordinates in positions\r\n});\r\n\r\n// convert radians to degrees\r\nfunction radToDeg(rad) {\r\n  return (rad * 360) / (Math.PI * 2);\r\n}\r\n// convert degrees to radians\r\nfunction degToRad(deg) {\r\n  return (deg * Math.PI * 2) / 360;\r\n}\r\n// modulo for negative values\r\nfunction mod(n) {\r\n  return ((n % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);\r\n}\r\n\r\nfunction addPosition(position, heading, m, speed) {\r\n  const x = position[0];\r\n  const y = position[1];\r\n  const fCoords = positions.getCoordinates();\r\n  const previous = fCoords[fCoords.length - 1];\r\n  const prevHeading = previous && previous[2];\r\n  if (prevHeading) {\r\n    let headingDiff = heading - mod(prevHeading);\r\n\r\n    // force the rotation change to be less than 180Â°\r\n    if (Math.abs(headingDiff) > Math.PI) {\r\n      const sign = headingDiff >= 0 ? 1 : -1;\r\n      headingDiff = -sign * (2 * Math.PI - Math.abs(headingDiff));\r\n    }\r\n    heading = prevHeading + headingDiff;\r\n  }\r\n  positions.appendCoordinate([x, y, heading, m]);\r\n\r\n  // only keep the 20 last coordinates\r\n  positions.setCoordinates(positions.getCoordinates().slice(-20));\r\n\r\n  // FIXME use speed instead\r\n  if (heading && speed) {\r\n    markerEl.src = 'data/geolocation_marker_heading.png';\r\n  } else {\r\n    markerEl.src = 'data/geolocation_marker.png';\r\n  }\r\n}\r\n\r\n// recenters the view by putting the given coordinates at 3/4 from the top or\r\n// the screen\r\nfunction getCenterWithHeading(position, rotation, resolution) {\r\n  const size = map.getSize();\r\n  const height = size[1];\r\n\r\n  return [\r\n    position[0] - (Math.sin(rotation) * height * resolution * 1) / 4,\r\n    position[1] + (Math.cos(rotation) * height * resolution * 1) / 4,\r\n  ];\r\n}\r\n\r\nlet previousM = 0;\r\nfunction updateView() {\r\n  // use sampling period to get a smooth transition\r\n  let m = Date.now() - deltaMean * 1.5;\r\n  m = Math.max(m, previousM);\r\n  previousM = m;\r\n  // interpolate position along positions LineString\r\n  const c = positions.getCoordinateAtM(m, true);\r\n  if (c) {\r\n    view.setCenter(getCenterWithHeading(c, -c[2], view.getResolution()));\r\n    view.setRotation(-c[2]);\r\n    marker.setPosition(c);\r\n    map.render();\r\n  }\r\n}\r\n\r\n// geolocate device\r\nconst geolocateBtn = document.getElementById('geolocate');\r\ngeolocateBtn.addEventListener(\r\n  'click',\r\n  function () {\r\n    geolocation.setTracking(true); // Start position tracking\r\n\r\n    tileLayer.on('postrender', updateView);\r\n    map.render();\r\n\r\n    disableButtons();\r\n  },\r\n  false\r\n);\r\n\r\n// simulate device move\r\nlet simulationData;\r\nconst client = new XMLHttpRequest();\r\nclient.open('GET', 'data/geolocation-orientation.json');\r\n\r\n/**\r\n * Handle data loading.\r\n */\r\nclient.onload = function () {\r\n  simulationData = JSON.parse(client.responseText).data;\r\n};\r\nclient.send();\r\n\r\nconst simulateBtn = document.getElementById('simulate');\r\nsimulateBtn.addEventListener(\r\n  'click',\r\n  function () {\r\n    const coordinates = simulationData;\r\n\r\n    const first = coordinates.shift();\r\n    simulatePositionChange(first);\r\n\r\n    let prevDate = first.timestamp;\r\n    function geolocate() {\r\n      const position = coordinates.shift();\r\n      if (!position) {\r\n        return;\r\n      }\r\n      const newDate = position.timestamp;\r\n      simulatePositionChange(position);\r\n      window.setTimeout(function () {\r\n        prevDate = newDate;\r\n        geolocate();\r\n      }, (newDate - prevDate) / 0.5);\r\n    }\r\n    geolocate();\r\n\r\n    tileLayer.on('postrender', updateView);\r\n    map.render();\r\n\r\n    disableButtons();\r\n  },\r\n  false\r\n);\r\n\r\nfunction simulatePositionChange(position) {\r\n  const coords = position.coords;\r\n  geolocation.set('accuracy', coords.accuracy);\r\n  geolocation.set('heading', degToRad(coords.heading));\r\n  const projectedPosition = fromLonLat([coords.longitude, coords.latitude]);\r\n  geolocation.set('position', projectedPosition);\r\n  geolocation.set('speed', coords.speed);\r\n  geolocation.changed();\r\n}\r\n\r\nfunction disableButtons() {\r\n  geolocateBtn.disabled = 'disabled';\r\n  simulateBtn.disabled = 'disabled';\r\n}\r\n"],"sourceRoot":""}