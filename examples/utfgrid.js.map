{"version":3,"sources":["webpack:///../src/ol/source/UTFGrid.js","webpack:///./utfgrid.js"],"names":["tileCoord","state","src","extent","preemptive","jsonp","super","this","src_","extent_","preemptive_","grid_","keys_","data_","jsonp_","getImage","getData","coordinate","const","xRelative","yRelative","row","Math","floor","length","let","code","charCodeAt","data","id","forDataAtCoordinate","callback","opt_request","TileState","EMPTY","IDLE","EventType","CHANGE","e","loadInternal_","setTimeout","bind","getKey","handleError_","ERROR","changed","handleLoad_","json","LOADED","LOADING","client","XMLHttpRequest","addEventListener","onXHRLoad_","onXHRError_","open","send","event","status","response","JSON","parse","responseText","err","load","setState","options","projection","undefined","tileUrlFunction_","template_","url","handleTileJSONResponse","handleTileJSONError","tileJSON","getTemplate","forDataAtCoordinateAndResolution","resolution","tileGrid","z","getZForResolution","zDirection","getTileCoordForCoordAndZ","getTile","getProjection","epsg4326Projection","sourceProjection","transform","minZoom","maxZoom","grids","attributionExtent","getExtent","setAttributions","frameState","READY","x","y","pixelRatio","tileCoordKey","tileCache","containsKey","get","urlTileCoord","getTileCoordForTileUrlFunction","tileUrl","tile","getTileCoordExtent","set","useTile","key","mapLayer","source","TileJSON","gridSource","gridLayer","view","View","center","zoom","mapElement","document","getElementById","map","Map","layers","target","infoElement","flagElement","nameElement","infoOverlay","Overlay","element","offset","stopEvent","addOverlay","displayCountryInfo","viewResolution","getResolution","style","cursor","innerHTML","setPosition","on","evt","dragging","getEventCoordinate","originalEvent"],"mappings":"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","file":"utfgrid.js","sourcesContent":["/**\r\n * @module ol/source/UTFGrid\r\n */\r\n\r\nimport EventType from '../events/EventType.js';\r\nimport SourceState from './State.js';\r\nimport Tile from '../Tile.js';\r\nimport TileSource from './Tile.js';\r\nimport TileState from '../TileState.js';\r\nimport {applyTransform, intersects} from '../extent.js';\r\nimport {assert} from '../asserts.js';\r\nimport {createFromTemplates, nullTileUrlFunction} from '../tileurlfunction.js';\r\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\r\nimport {getKeyZXY} from '../tilecoord.js';\r\nimport {get as getProjection, getTransformFromProjections} from '../proj.js';\r\nimport {listenOnce} from '../events.js';\r\nimport {jsonp as requestJSONP} from '../net.js';\r\n\r\n/**\r\n * @typedef {Object} UTFGridJSON\r\n * @property {Array<string>} grid The grid.\r\n * @property {Array<string>} keys The keys.\r\n * @property {Object<string, Object>} [data] Optional data.\r\n */\r\n\r\nexport class CustomTile extends Tile {\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"../TileState.js\").default} state State.\r\n   * @param {string} src Image source URI.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent of the tile.\r\n   * @param {boolean} preemptive Load the tile when visible (before it's needed).\r\n   * @param {boolean} jsonp Load the tile as a script.\r\n   */\r\n  constructor(tileCoord, state, src, extent, preemptive, jsonp) {\r\n    super(tileCoord, state);\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.src_ = src;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.extent_ = extent;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.preemptive_ = preemptive;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<string>}\r\n     */\r\n    this.grid_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<string>}\r\n     */\r\n    this.keys_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, Object>|undefined}\r\n     */\r\n    this.data_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.jsonp_ = jsonp;\r\n  }\r\n\r\n  /**\r\n   * Get the image element for this tile.\r\n   * @return {HTMLImageElement} Image.\r\n   */\r\n  getImage() {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Synchronously returns data at given coordinate (if available).\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @return {*} The data.\r\n   */\r\n  getData(coordinate) {\r\n    if (!this.grid_ || !this.keys_) {\r\n      return null;\r\n    }\r\n    const xRelative =\r\n      (coordinate[0] - this.extent_[0]) / (this.extent_[2] - this.extent_[0]);\r\n    const yRelative =\r\n      (coordinate[1] - this.extent_[1]) / (this.extent_[3] - this.extent_[1]);\r\n\r\n    const row = this.grid_[Math.floor((1 - yRelative) * this.grid_.length)];\r\n\r\n    if (typeof row !== 'string') {\r\n      return null;\r\n    }\r\n\r\n    let code = row.charCodeAt(Math.floor(xRelative * row.length));\r\n    if (code >= 93) {\r\n      code--;\r\n    }\r\n    if (code >= 35) {\r\n      code--;\r\n    }\r\n    code -= 32;\r\n\r\n    let data = null;\r\n    if (code in this.keys_) {\r\n      const id = this.keys_[code];\r\n      if (this.data_ && id in this.data_) {\r\n        data = this.data_[id];\r\n      } else {\r\n        data = id;\r\n      }\r\n    }\r\n    return data;\r\n  }\r\n\r\n  /**\r\n   * Calls the callback (synchronously by default) with the available data\r\n   * for given coordinate (or `null` if not yet loaded).\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {function(*): void} callback Callback.\r\n   * @param {boolean=} opt_request If `true` the callback is always async.\r\n   *                               The tile data is requested if not yet loaded.\r\n   */\r\n  forDataAtCoordinate(coordinate, callback, opt_request) {\r\n    if (this.state == TileState.EMPTY && opt_request === true) {\r\n      this.state = TileState.IDLE;\r\n      listenOnce(\r\n        this,\r\n        EventType.CHANGE,\r\n        function (e) {\r\n          callback(this.getData(coordinate));\r\n        },\r\n        this\r\n      );\r\n      this.loadInternal_();\r\n    } else {\r\n      if (opt_request === true) {\r\n        setTimeout(\r\n          function () {\r\n            callback(this.getData(coordinate));\r\n          }.bind(this),\r\n          0\r\n        );\r\n      } else {\r\n        callback(this.getData(coordinate));\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return the key to be used for all tiles in the source.\r\n   * @return {string} The key for all tiles.\r\n   */\r\n  getKey() {\r\n    return this.src_;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  handleError_() {\r\n    this.state = TileState.ERROR;\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * @param {!UTFGridJSON} json UTFGrid data.\r\n   * @private\r\n   */\r\n  handleLoad_(json) {\r\n    this.grid_ = json['grid'];\r\n    this.keys_ = json['keys'];\r\n    this.data_ = json['data'];\r\n\r\n    this.state = TileState.LOADED;\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  loadInternal_() {\r\n    if (this.state == TileState.IDLE) {\r\n      this.state = TileState.LOADING;\r\n      if (this.jsonp_) {\r\n        requestJSONP(\r\n          this.src_,\r\n          this.handleLoad_.bind(this),\r\n          this.handleError_.bind(this)\r\n        );\r\n      } else {\r\n        const client = new XMLHttpRequest();\r\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\r\n        client.addEventListener('error', this.onXHRError_.bind(this));\r\n        client.open('GET', this.src_);\r\n        client.send();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {Event} event The load event.\r\n   */\r\n  onXHRLoad_(event) {\r\n    const client = /** @type {XMLHttpRequest} */ (event.target);\r\n    // status will be 0 for file:// urls\r\n    if (!client.status || (client.status >= 200 && client.status < 300)) {\r\n      let response;\r\n      try {\r\n        response = /** @type {!UTFGridJSON} */ (JSON.parse(\r\n          client.responseText\r\n        ));\r\n      } catch (err) {\r\n        this.handleError_();\r\n        return;\r\n      }\r\n      this.handleLoad_(response);\r\n    } else {\r\n      this.handleError_();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {Event} event The error event.\r\n   */\r\n  onXHRError_(event) {\r\n    this.handleError_();\r\n  }\r\n\r\n  /**\r\n   */\r\n  load() {\r\n    if (this.preemptive_) {\r\n      this.loadInternal_();\r\n    } else {\r\n      this.setState(TileState.EMPTY);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {boolean} [preemptive=true]\r\n * If `true` the UTFGrid source loads the tiles based on their \"visibility\".\r\n * This improves the speed of response, but increases traffic.\r\n * Note that if set to `false` (lazy loading), you need to pass `true` as\r\n * `opt_request` to the `forDataAtCoordinateAndResolution` method otherwise no\r\n * data will ever be loaded.\r\n * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.\r\n * Useful when the server does not support CORS..\r\n * @property {import(\"./TileJSON.js\").Config} [tileJSON] TileJSON configuration for this source.\r\n * If not provided, `url` must be configured.\r\n * @property {string} [url] TileJSON endpoint that provides the configuration for this source.\r\n * Request will be made through JSONP. If not provided, `tileJSON` must be configured.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Layer source for UTFGrid interaction data loaded from TileJSON format.\r\n * @api\r\n */\r\nclass UTFGrid extends TileSource {\r\n  /**\r\n   * @param {Options} options Source options.\r\n   */\r\n  constructor(options) {\r\n    super({\r\n      projection: getProjection('EPSG:3857'),\r\n      state: SourceState.LOADING,\r\n    });\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.preemptive_ =\r\n      options.preemptive !== undefined ? options.preemptive : true;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!import(\"../Tile.js\").UrlFunction}\r\n     */\r\n    this.tileUrlFunction_ = nullTileUrlFunction;\r\n\r\n    /**\r\n     * @private\r\n     * @type {string|undefined}\r\n     */\r\n    this.template_ = undefined;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.jsonp_ = options.jsonp || false;\r\n\r\n    if (options.url) {\r\n      if (this.jsonp_) {\r\n        requestJSONP(\r\n          options.url,\r\n          this.handleTileJSONResponse.bind(this),\r\n          this.handleTileJSONError.bind(this)\r\n        );\r\n      } else {\r\n        const client = new XMLHttpRequest();\r\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\r\n        client.addEventListener('error', this.onXHRError_.bind(this));\r\n        client.open('GET', options.url);\r\n        client.send();\r\n      }\r\n    } else if (options.tileJSON) {\r\n      this.handleTileJSONResponse(options.tileJSON);\r\n    } else {\r\n      assert(false, 51); // Either `url` or `tileJSON` options must be provided\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {Event} event The load event.\r\n   */\r\n  onXHRLoad_(event) {\r\n    const client = /** @type {XMLHttpRequest} */ (event.target);\r\n    // status will be 0 for file:// urls\r\n    if (!client.status || (client.status >= 200 && client.status < 300)) {\r\n      let response;\r\n      try {\r\n        response = /** @type {import(\"./TileJSON.js\").Config} */ (JSON.parse(\r\n          client.responseText\r\n        ));\r\n      } catch (err) {\r\n        this.handleTileJSONError();\r\n        return;\r\n      }\r\n      this.handleTileJSONResponse(response);\r\n    } else {\r\n      this.handleTileJSONError();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {Event} event The error event.\r\n   */\r\n  onXHRError_(event) {\r\n    this.handleTileJSONError();\r\n  }\r\n\r\n  /**\r\n   * Return the template from TileJSON.\r\n   * @return {string|undefined} The template from TileJSON.\r\n   * @api\r\n   */\r\n  getTemplate() {\r\n    return this.template_;\r\n  }\r\n\r\n  /**\r\n   * Calls the callback (synchronously by default) with the available data\r\n   * for given coordinate and resolution (or `null` if not yet loaded or\r\n   * in case of an error).\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {number} resolution Resolution.\r\n   * @param {function(*): void} callback Callback.\r\n   * @param {boolean=} opt_request If `true` the callback is always async.\r\n   *                               The tile data is requested if not yet loaded.\r\n   * @api\r\n   */\r\n  forDataAtCoordinateAndResolution(\r\n    coordinate,\r\n    resolution,\r\n    callback,\r\n    opt_request\r\n  ) {\r\n    if (this.tileGrid) {\r\n      const z = this.tileGrid.getZForResolution(resolution, this.zDirection);\r\n      const tileCoord = this.tileGrid.getTileCoordForCoordAndZ(coordinate, z);\r\n      const tile = /** @type {!CustomTile} */ (this.getTile(\r\n        tileCoord[0],\r\n        tileCoord[1],\r\n        tileCoord[2],\r\n        1,\r\n        this.getProjection()\r\n      ));\r\n      tile.forDataAtCoordinate(coordinate, callback, opt_request);\r\n    } else {\r\n      if (opt_request === true) {\r\n        setTimeout(function () {\r\n          callback(null);\r\n        }, 0);\r\n      } else {\r\n        callback(null);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  handleTileJSONError() {\r\n    this.setState(SourceState.ERROR);\r\n  }\r\n\r\n  /**\r\n   * TODO: very similar to ol/source/TileJSON#handleTileJSONResponse\r\n   * @protected\r\n   * @param {import(\"./TileJSON.js\").Config} tileJSON Tile JSON.\r\n   */\r\n  handleTileJSONResponse(tileJSON) {\r\n    const epsg4326Projection = getProjection('EPSG:4326');\r\n\r\n    const sourceProjection = this.getProjection();\r\n    let extent;\r\n    if (tileJSON['bounds'] !== undefined) {\r\n      const transform = getTransformFromProjections(\r\n        epsg4326Projection,\r\n        sourceProjection\r\n      );\r\n      extent = applyTransform(tileJSON['bounds'], transform);\r\n    }\r\n\r\n    const minZoom = tileJSON['minzoom'] || 0;\r\n    const maxZoom = tileJSON['maxzoom'] || 22;\r\n    const tileGrid = createXYZ({\r\n      extent: extentFromProjection(sourceProjection),\r\n      maxZoom: maxZoom,\r\n      minZoom: minZoom,\r\n    });\r\n    this.tileGrid = tileGrid;\r\n\r\n    this.template_ = tileJSON['template'];\r\n\r\n    const grids = tileJSON['grids'];\r\n    if (!grids) {\r\n      this.setState(SourceState.ERROR);\r\n      return;\r\n    }\r\n\r\n    this.tileUrlFunction_ = createFromTemplates(grids, tileGrid);\r\n\r\n    if (tileJSON['attribution'] !== undefined) {\r\n      const attributionExtent =\r\n        extent !== undefined ? extent : epsg4326Projection.getExtent();\r\n\r\n      this.setAttributions(function (frameState) {\r\n        if (intersects(attributionExtent, frameState.extent)) {\r\n          return [tileJSON['attribution']];\r\n        }\r\n        return null;\r\n      });\r\n    }\r\n\r\n    this.setState(SourceState.READY);\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {!CustomTile} Tile.\r\n   */\r\n  getTile(z, x, y, pixelRatio, projection) {\r\n    const tileCoordKey = getKeyZXY(z, x, y);\r\n    if (this.tileCache.containsKey(tileCoordKey)) {\r\n      return this.tileCache.get(tileCoordKey);\r\n    } else {\r\n      const tileCoord = [z, x, y];\r\n      const urlTileCoord = this.getTileCoordForTileUrlFunction(\r\n        tileCoord,\r\n        projection\r\n      );\r\n      const tileUrl = this.tileUrlFunction_(\r\n        urlTileCoord,\r\n        pixelRatio,\r\n        projection\r\n      );\r\n      const tile = new CustomTile(\r\n        tileCoord,\r\n        tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY,\r\n        tileUrl !== undefined ? tileUrl : '',\r\n        this.tileGrid.getTileCoordExtent(tileCoord),\r\n        this.preemptive_,\r\n        this.jsonp_\r\n      );\r\n      this.tileCache.set(tileCoordKey, tile);\r\n      return tile;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Marks a tile coord as being used, without triggering a load.\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   */\r\n  useTile(z, x, y) {\r\n    const tileCoordKey = getKeyZXY(z, x, y);\r\n    if (this.tileCache.containsKey(tileCoordKey)) {\r\n      this.tileCache.get(tileCoordKey);\r\n    }\r\n  }\r\n}\r\n\r\nexport default UTFGrid;\r\n","import Map from '../src/ol/Map.js';\r\nimport Overlay from '../src/ol/Overlay.js';\r\nimport TileJSON from '../src/ol/source/TileJSON.js';\r\nimport TileLayer from '../src/ol/layer/Tile.js';\r\nimport UTFGrid from '../src/ol/source/UTFGrid.js';\r\nimport View from '../src/ol/View.js';\r\n\r\nconst key =\r\n  'pk.eyJ1IjoiYWhvY2V2YXIiLCJhIjoiY2pzbmg0Nmk5MGF5NzQzbzRnbDNoeHJrbiJ9.7_-_gL8ur7ZtEiNwRfCy7Q';\r\n\r\nconst mapLayer = new TileLayer({\r\n  source: new TileJSON({\r\n    url:\r\n      'https://api.tiles.mapbox.com/v4/mapbox.geography-class.json?secure&access_token=' +\r\n      key,\r\n  }),\r\n});\r\n\r\nconst gridSource = new UTFGrid({\r\n  url:\r\n    'https://api.tiles.mapbox.com/v4/mapbox.geography-class.json?secure&access_token=' +\r\n    key,\r\n});\r\n\r\nconst gridLayer = new TileLayer({source: gridSource});\r\n\r\nconst view = new View({\r\n  center: [0, 0],\r\n  zoom: 1,\r\n});\r\n\r\nconst mapElement = document.getElementById('map');\r\nconst map = new Map({\r\n  layers: [mapLayer, gridLayer],\r\n  target: mapElement,\r\n  view: view,\r\n});\r\n\r\nconst infoElement = document.getElementById('country-info');\r\nconst flagElement = document.getElementById('country-flag');\r\nconst nameElement = document.getElementById('country-name');\r\n\r\nconst infoOverlay = new Overlay({\r\n  element: infoElement,\r\n  offset: [15, 15],\r\n  stopEvent: false,\r\n});\r\nmap.addOverlay(infoOverlay);\r\n\r\nconst displayCountryInfo = function (coordinate) {\r\n  const viewResolution = /** @type {number} */ (view.getResolution());\r\n  gridSource.forDataAtCoordinateAndResolution(\r\n    coordinate,\r\n    viewResolution,\r\n    function (data) {\r\n      // If you want to use the template from the TileJSON,\r\n      //  load the mustache.js library separately and call\r\n      //  info.innerHTML = Mustache.render(gridSource.getTemplate(), data);\r\n      mapElement.style.cursor = data ? 'pointer' : '';\r\n      if (data) {\r\n        flagElement.src = 'data:image/png;base64,' + data['flag_png'];\r\n        nameElement.innerHTML = data['admin'];\r\n      }\r\n      infoOverlay.setPosition(data ? coordinate : undefined);\r\n    }\r\n  );\r\n};\r\n\r\nmap.on('pointermove', function (evt) {\r\n  if (evt.dragging) {\r\n    return;\r\n  }\r\n  const coordinate = map.getEventCoordinate(evt.originalEvent);\r\n  displayCountryInfo(coordinate);\r\n});\r\n\r\nmap.on('click', function (evt) {\r\n  displayCountryInfo(evt.coordinate);\r\n});\r\n"],"sourceRoot":""}