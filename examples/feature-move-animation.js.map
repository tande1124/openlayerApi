{"version":3,"sources":["webpack:///../src/ol/geom/flat/flip.js","webpack:///../src/ol/format/Polyline.js","webpack:///./feature-move-animation.js"],"names":["flipXY","flatCoordinates","offset","end","stride","opt_dest","opt_destOffset","let","dest","destOffset","undefined","j","const","x","k","length","encodeUnsignedInteger","num","value","encoded","String","fromCharCode","opt_options","super","options","this","dataProjection","factor_","factor","geometryLayout_","geometryLayout","GeometryLayout","XY","readFeatureFromText","text","geometry","readGeometryFromText","Feature","readFeaturesFromText","opt_factor","d","lastNumbers","Array","numbers","current","shift","i","ii","b","charCodeAt","push","decodeUnsignedIntegers","decodeSignedIntegers","decodeFloats","decodeDeltas","coordinates","inflate","lineString","LineString","adaptOptions","writeFeatureText","feature","getGeometry","writeGeometryText","writeFeaturesText","features","getFlatCoordinates","getStride","delta","Math","round","encodeUnsignedIntegers","encodeSignedIntegers","encodeFloats","encodeDeltas","center","map","Map","target","document","getElementById","view","View","zoom","minZoom","maxZoom","layers","Tile","source","XYZ","attributions","url","tileSize","fetch","then","response","json","result","speed","startTime","polyline","routes","route","readGeometry","featureProjection","routeFeature","type","geoMarker","Point","getCoordinateAt","startMarker","endMarker","styles","Style","stroke","Stroke","width","color","image","Icon","anchor","src","Circle","radius","fill","Fill","animating","vectorLayer","Vector","style","get","addLayer","speedInput","startButton","moveFeature","event","vectorContext","frameState","elapsedTime","time","distance","stopAnimation","currentPoint","drawFeature","render","ended","textContent","coord","setCoordinates","un","addEventListener","Date","getTime","changed","getView","setCenter","on"],"mappings":"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","file":"feature-move-animation.js","sourcesContent":["/**\r\n * @module ol/geom/flat/flip\r\n */\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {Array<number>=} opt_dest Destination.\r\n * @param {number=} opt_destOffset Destination offset.\r\n * @return {Array<number>} Flat coordinates.\r\n */\r\nexport function flipXY(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  opt_dest,\r\n  opt_destOffset\r\n) {\r\n  let dest, destOffset;\r\n  if (opt_dest !== undefined) {\r\n    dest = opt_dest;\r\n    destOffset = opt_destOffset !== undefined ? opt_destOffset : 0;\r\n  } else {\r\n    dest = [];\r\n    destOffset = 0;\r\n  }\r\n  let j = offset;\r\n  while (j < end) {\r\n    const x = flatCoordinates[j++];\r\n    dest[destOffset++] = flatCoordinates[j++];\r\n    dest[destOffset++] = x;\r\n    for (let k = 2; k < stride; ++k) {\r\n      dest[destOffset++] = flatCoordinates[j++];\r\n    }\r\n  }\r\n  dest.length = destOffset;\r\n  return dest;\r\n}\r\n","/**\r\n * @module ol/format/Polyline\r\n */\r\nimport Feature from '../Feature.js';\r\nimport GeometryLayout from '../geom/GeometryLayout.js';\r\nimport LineString from '../geom/LineString.js';\r\nimport TextFeature from './TextFeature.js';\r\nimport {assert} from '../asserts.js';\r\nimport {flipXY} from '../geom/flat/flip.js';\r\nimport {get as getProjection} from '../proj.js';\r\nimport {getStrideForLayout} from '../geom/SimpleGeometry.js';\r\nimport {inflateCoordinates} from '../geom/flat/inflate.js';\r\nimport {transformGeometryWithOptions} from './Feature.js';\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {number} [factor=1e5] The factor by which the coordinates values will be scaled.\r\n * @property {GeometryLayout} [geometryLayout='XY'] Layout of the\r\n * feature geometries created by the format reader.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Feature format for reading and writing data in the Encoded\r\n * Polyline Algorithm Format.\r\n *\r\n * When reading features, the coordinates are assumed to be in two dimensions\r\n * and in [latitude, longitude] order.\r\n *\r\n * As Polyline sources contain a single feature,\r\n * {@link module:ol/format/Polyline~Polyline#readFeatures} will return the\r\n * feature in an array.\r\n *\r\n * @api\r\n */\r\nclass Polyline extends TextFeature {\r\n  /**\r\n   * @param {Options=} opt_options Optional configuration object.\r\n   */\r\n  constructor(opt_options) {\r\n    super();\r\n\r\n    const options = opt_options ? opt_options : {};\r\n\r\n    /**\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     */\r\n    this.dataProjection = getProjection('EPSG:4326');\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.factor_ = options.factor ? options.factor : 1e5;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../geom/GeometryLayout\").default}\r\n     */\r\n    this.geometryLayout_ = options.geometryLayout\r\n      ? options.geometryLayout\r\n      : GeometryLayout.XY;\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {string} text Text.\r\n   * @param {import(\"./Feature.js\").ReadOptions=} opt_options Read options.\r\n   * @return {import(\"../Feature.js\").default} Feature.\r\n   */\r\n  readFeatureFromText(text, opt_options) {\r\n    const geometry = this.readGeometryFromText(text, opt_options);\r\n    return new Feature(geometry);\r\n  }\r\n\r\n  /**\r\n   * @param {string} text Text.\r\n   * @param {import(\"./Feature.js\").ReadOptions=} opt_options Read options.\r\n   * @protected\r\n   * @return {Array<Feature>} Features.\r\n   */\r\n  readFeaturesFromText(text, opt_options) {\r\n    const feature = this.readFeatureFromText(text, opt_options);\r\n    return [feature];\r\n  }\r\n\r\n  /**\r\n   * @param {string} text Text.\r\n   * @param {import(\"./Feature.js\").ReadOptions=} opt_options Read options.\r\n   * @protected\r\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\r\n   */\r\n  readGeometryFromText(text, opt_options) {\r\n    const stride = getStrideForLayout(this.geometryLayout_);\r\n    const flatCoordinates = decodeDeltas(text, stride, this.factor_);\r\n    flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);\r\n    const coordinates = inflateCoordinates(\r\n      flatCoordinates,\r\n      0,\r\n      flatCoordinates.length,\r\n      stride\r\n    );\r\n    const lineString = new LineString(coordinates, this.geometryLayout_);\r\n\r\n    return transformGeometryWithOptions(\r\n      lineString,\r\n      false,\r\n      this.adaptOptions(opt_options)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../Feature.js\").default} feature Features.\r\n   * @param {import(\"./Feature.js\").WriteOptions=} opt_options Write options.\r\n   * @protected\r\n   * @return {string} Text.\r\n   */\r\n  writeFeatureText(feature, opt_options) {\r\n    const geometry = feature.getGeometry();\r\n    if (geometry) {\r\n      return this.writeGeometryText(geometry, opt_options);\r\n    } else {\r\n      assert(false, 40); // Expected `feature` to have a geometry\r\n      return '';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\r\n   * @param {import(\"./Feature.js\").WriteOptions=} opt_options Write options.\r\n   * @protected\r\n   * @return {string} Text.\r\n   */\r\n  writeFeaturesText(features, opt_options) {\r\n    return this.writeFeatureText(features[0], opt_options);\r\n  }\r\n\r\n  /**\r\n   * @param {LineString} geometry Geometry.\r\n   * @param {import(\"./Feature.js\").WriteOptions=} opt_options Write options.\r\n   * @protected\r\n   * @return {string} Text.\r\n   */\r\n  writeGeometryText(geometry, opt_options) {\r\n    geometry =\r\n      /** @type {LineString} */\r\n      (transformGeometryWithOptions(\r\n        geometry,\r\n        true,\r\n        this.adaptOptions(opt_options)\r\n      ));\r\n    const flatCoordinates = geometry.getFlatCoordinates();\r\n    const stride = geometry.getStride();\r\n    flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);\r\n    return encodeDeltas(flatCoordinates, stride, this.factor_);\r\n  }\r\n}\r\n\r\n/**\r\n * Encode a list of n-dimensional points and return an encoded string\r\n *\r\n * Attention: This function will modify the passed array!\r\n *\r\n * @param {Array<number>} numbers A list of n-dimensional points.\r\n * @param {number} stride The number of dimension of the points in the list.\r\n * @param {number=} opt_factor The factor by which the numbers will be\r\n *     multiplied. The remaining decimal places will get rounded away.\r\n *     Default is `1e5`.\r\n * @return {string} The encoded string.\r\n * @api\r\n */\r\nexport function encodeDeltas(numbers, stride, opt_factor) {\r\n  const factor = opt_factor ? opt_factor : 1e5;\r\n  let d;\r\n\r\n  const lastNumbers = new Array(stride);\r\n  for (d = 0; d < stride; ++d) {\r\n    lastNumbers[d] = 0;\r\n  }\r\n\r\n  for (let i = 0, ii = numbers.length; i < ii; ) {\r\n    for (d = 0; d < stride; ++d, ++i) {\r\n      const num = numbers[i];\r\n      const delta = num - lastNumbers[d];\r\n      lastNumbers[d] = num;\r\n\r\n      numbers[i] = delta;\r\n    }\r\n  }\r\n\r\n  return encodeFloats(numbers, factor);\r\n}\r\n\r\n/**\r\n * Decode a list of n-dimensional points from an encoded string\r\n *\r\n * @param {string} encoded An encoded string.\r\n * @param {number} stride The number of dimension of the points in the\r\n *     encoded string.\r\n * @param {number=} opt_factor The factor by which the resulting numbers will\r\n *     be divided. Default is `1e5`.\r\n * @return {Array<number>} A list of n-dimensional points.\r\n * @api\r\n */\r\nexport function decodeDeltas(encoded, stride, opt_factor) {\r\n  const factor = opt_factor ? opt_factor : 1e5;\r\n  let d;\r\n\r\n  /** @type {Array<number>} */\r\n  const lastNumbers = new Array(stride);\r\n  for (d = 0; d < stride; ++d) {\r\n    lastNumbers[d] = 0;\r\n  }\r\n\r\n  const numbers = decodeFloats(encoded, factor);\r\n\r\n  for (let i = 0, ii = numbers.length; i < ii; ) {\r\n    for (d = 0; d < stride; ++d, ++i) {\r\n      lastNumbers[d] += numbers[i];\r\n\r\n      numbers[i] = lastNumbers[d];\r\n    }\r\n  }\r\n\r\n  return numbers;\r\n}\r\n\r\n/**\r\n * Encode a list of floating point numbers and return an encoded string\r\n *\r\n * Attention: This function will modify the passed array!\r\n *\r\n * @param {Array<number>} numbers A list of floating point numbers.\r\n * @param {number=} opt_factor The factor by which the numbers will be\r\n *     multiplied. The remaining decimal places will get rounded away.\r\n *     Default is `1e5`.\r\n * @return {string} The encoded string.\r\n * @api\r\n */\r\nexport function encodeFloats(numbers, opt_factor) {\r\n  const factor = opt_factor ? opt_factor : 1e5;\r\n  for (let i = 0, ii = numbers.length; i < ii; ++i) {\r\n    numbers[i] = Math.round(numbers[i] * factor);\r\n  }\r\n\r\n  return encodeSignedIntegers(numbers);\r\n}\r\n\r\n/**\r\n * Decode a list of floating point numbers from an encoded string\r\n *\r\n * @param {string} encoded An encoded string.\r\n * @param {number=} opt_factor The factor by which the result will be divided.\r\n *     Default is `1e5`.\r\n * @return {Array<number>} A list of floating point numbers.\r\n * @api\r\n */\r\nexport function decodeFloats(encoded, opt_factor) {\r\n  const factor = opt_factor ? opt_factor : 1e5;\r\n  const numbers = decodeSignedIntegers(encoded);\r\n  for (let i = 0, ii = numbers.length; i < ii; ++i) {\r\n    numbers[i] /= factor;\r\n  }\r\n  return numbers;\r\n}\r\n\r\n/**\r\n * Encode a list of signed integers and return an encoded string\r\n *\r\n * Attention: This function will modify the passed array!\r\n *\r\n * @param {Array<number>} numbers A list of signed integers.\r\n * @return {string} The encoded string.\r\n */\r\nexport function encodeSignedIntegers(numbers) {\r\n  for (let i = 0, ii = numbers.length; i < ii; ++i) {\r\n    const num = numbers[i];\r\n    numbers[i] = num < 0 ? ~(num << 1) : num << 1;\r\n  }\r\n  return encodeUnsignedIntegers(numbers);\r\n}\r\n\r\n/**\r\n * Decode a list of signed integers from an encoded string\r\n *\r\n * @param {string} encoded An encoded string.\r\n * @return {Array<number>} A list of signed integers.\r\n */\r\nexport function decodeSignedIntegers(encoded) {\r\n  const numbers = decodeUnsignedIntegers(encoded);\r\n  for (let i = 0, ii = numbers.length; i < ii; ++i) {\r\n    const num = numbers[i];\r\n    numbers[i] = num & 1 ? ~(num >> 1) : num >> 1;\r\n  }\r\n  return numbers;\r\n}\r\n\r\n/**\r\n * Encode a list of unsigned integers and return an encoded string\r\n *\r\n * @param {Array<number>} numbers A list of unsigned integers.\r\n * @return {string} The encoded string.\r\n */\r\nexport function encodeUnsignedIntegers(numbers) {\r\n  let encoded = '';\r\n  for (let i = 0, ii = numbers.length; i < ii; ++i) {\r\n    encoded += encodeUnsignedInteger(numbers[i]);\r\n  }\r\n  return encoded;\r\n}\r\n\r\n/**\r\n * Decode a list of unsigned integers from an encoded string\r\n *\r\n * @param {string} encoded An encoded string.\r\n * @return {Array<number>} A list of unsigned integers.\r\n */\r\nexport function decodeUnsignedIntegers(encoded) {\r\n  const numbers = [];\r\n  let current = 0;\r\n  let shift = 0;\r\n  for (let i = 0, ii = encoded.length; i < ii; ++i) {\r\n    const b = encoded.charCodeAt(i) - 63;\r\n    current |= (b & 0x1f) << shift;\r\n    if (b < 0x20) {\r\n      numbers.push(current);\r\n      current = 0;\r\n      shift = 0;\r\n    } else {\r\n      shift += 5;\r\n    }\r\n  }\r\n  return numbers;\r\n}\r\n\r\n/**\r\n * Encode one single unsigned integer and return an encoded string\r\n *\r\n * @param {number} num Unsigned integer that should be encoded.\r\n * @return {string} The encoded string.\r\n */\r\nexport function encodeUnsignedInteger(num) {\r\n  let value,\r\n    encoded = '';\r\n  while (num >= 0x20) {\r\n    value = (0x20 | (num & 0x1f)) + 63;\r\n    encoded += String.fromCharCode(value);\r\n    num >>= 5;\r\n  }\r\n  value = num + 63;\r\n  encoded += String.fromCharCode(value);\r\n  return encoded;\r\n}\r\n\r\nexport default Polyline;\r\n","import Feature from '../src/ol/Feature.js';\r\nimport Map from '../src/ol/Map.js';\r\nimport Point from '../src/ol/geom/Point.js';\r\nimport Polyline from '../src/ol/format/Polyline.js';\r\nimport VectorSource from '../src/ol/source/Vector.js';\r\nimport View from '../src/ol/View.js';\r\nimport XYZ from '../src/ol/source/XYZ.js';\r\nimport {\r\n  Circle as CircleStyle,\r\n  Fill,\r\n  Icon,\r\n  Stroke,\r\n  Style,\r\n} from '../src/ol/style.js';\r\nimport {Tile as TileLayer, Vector as VectorLayer} from '../src/ol/layer.js';\r\nimport {getVectorContext} from '../src/ol/render.js';\r\n\r\nconst key = 'get_your_own_D6rA4zTHduk6KOKTXzGB';\r\nconst attributions =\r\n  '<a href=\"https://www.maptiler.com/copyright/\" target=\"_blank\">&copy; MapTiler</a> ' +\r\n  '<a href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\">&copy; OpenStreetMap contributors</a>';\r\n\r\nconst center = [-5639523.95, -3501274.52];\r\nconst map = new Map({\r\n  target: document.getElementById('map'),\r\n  view: new View({\r\n    center: center,\r\n    zoom: 10,\r\n    minZoom: 2,\r\n    maxZoom: 19,\r\n  }),\r\n  layers: [\r\n    new TileLayer({\r\n      source: new XYZ({\r\n        attributions: attributions,\r\n        url: 'https://api.maptiler.com/maps/hybrid/{z}/{x}/{y}.jpg?key=' + key,\r\n        tileSize: 512,\r\n      }),\r\n    }),\r\n  ],\r\n});\r\n\r\n// The polyline string is read from a JSON similiar to those returned\r\n// by directions APIs such as Openrouteservice and Mapbox.\r\nfetch('data/polyline/route.json').then(function (response) {\r\n  response.json().then(function (result) {\r\n    const polyline = result.routes[0].geometry;\r\n\r\n    const route = new Polyline({\r\n      factor: 1e6,\r\n    }).readGeometry(polyline, {\r\n      dataProjection: 'EPSG:4326',\r\n      featureProjection: 'EPSG:3857',\r\n    });\r\n\r\n    const routeFeature = new Feature({\r\n      type: 'route',\r\n      geometry: route,\r\n    });\r\n    const geoMarker = new Feature({\r\n      type: 'geoMarker',\r\n      geometry: new Point(route.getCoordinateAt(0)),\r\n    });\r\n    const startMarker = new Feature({\r\n      type: 'icon',\r\n      geometry: new Point(route.getCoordinateAt(0)),\r\n    });\r\n    const endMarker = new Feature({\r\n      type: 'icon',\r\n      geometry: new Point(route.getCoordinateAt(1)),\r\n    });\r\n\r\n    const styles = {\r\n      'route': new Style({\r\n        stroke: new Stroke({\r\n          width: 6,\r\n          color: [237, 212, 0, 0.8],\r\n        }),\r\n      }),\r\n      'icon': new Style({\r\n        image: new Icon({\r\n          anchor: [0.5, 1],\r\n          src: 'data/icon.png',\r\n        }),\r\n      }),\r\n      'geoMarker': new Style({\r\n        image: new CircleStyle({\r\n          radius: 7,\r\n          fill: new Fill({color: 'black'}),\r\n          stroke: new Stroke({\r\n            color: 'white',\r\n            width: 2,\r\n          }),\r\n        }),\r\n      }),\r\n    };\r\n\r\n    let animating = false;\r\n\r\n    const vectorLayer = new VectorLayer({\r\n      source: new VectorSource({\r\n        features: [routeFeature, geoMarker, startMarker, endMarker],\r\n      }),\r\n      style: function (feature) {\r\n        // hide geoMarker if animation is active\r\n        if (animating && feature.get('type') === 'geoMarker') {\r\n          return null;\r\n        }\r\n        return styles[feature.get('type')];\r\n      },\r\n    });\r\n\r\n    map.addLayer(vectorLayer);\r\n\r\n    let speed, startTime;\r\n    const speedInput = document.getElementById('speed');\r\n    const startButton = document.getElementById('start-animation');\r\n\r\n    function moveFeature(event) {\r\n      const vectorContext = getVectorContext(event);\r\n      const frameState = event.frameState;\r\n\r\n      if (animating) {\r\n        const elapsedTime = frameState.time - startTime;\r\n        const distance = (speed * elapsedTime) / 1e6;\r\n\r\n        if (distance >= 1) {\r\n          stopAnimation(true);\r\n          return;\r\n        }\r\n\r\n        const currentPoint = new Point(route.getCoordinateAt(distance));\r\n        const feature = new Feature(currentPoint);\r\n        vectorContext.drawFeature(feature, styles.geoMarker);\r\n      }\r\n      // tell OpenLayers to continue the postrender animation\r\n      map.render();\r\n    }\r\n\r\n    function startAnimation() {\r\n      if (animating) {\r\n        stopAnimation(false);\r\n      } else {\r\n        animating = true;\r\n        startTime = new Date().getTime();\r\n        speed = speedInput.value;\r\n        startButton.textContent = 'Cancel Animation';\r\n        // hide geoMarker\r\n        geoMarker.changed();\r\n        // just in case you pan somewhere else\r\n        map.getView().setCenter(center);\r\n        vectorLayer.on('postrender', moveFeature);\r\n        map.render();\r\n      }\r\n    }\r\n\r\n    function stopAnimation(ended) {\r\n      animating = false;\r\n      startButton.textContent = 'Start Animation';\r\n\r\n      // if animation cancelled set the marker at the beginning\r\n      const coord = route.getCoordinateAt(ended ? 1 : 0);\r\n      geoMarker.getGeometry().setCoordinates(coord);\r\n      // remove listener\r\n      vectorLayer.un('postrender', moveFeature);\r\n    }\r\n\r\n    startButton.addEventListener('click', startAnimation, false);\r\n  });\r\n});\r\n"],"sourceRoot":""}