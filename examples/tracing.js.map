{"version":3,"sources":["webpack:///./tracing.js"],"names":["length","a","b","Math","sqrt","isOnSegment","c","const","lengthAc","lengthAb","dot","abs","mod","getPartialRingCoords","feature","startPoint","endPoint","let","polygon","getGeometry","getType","getPolygon","i","pointA","pointB","ringCoords","getLinearRing","getCoordinates","startSegmentIndex","cwCoordinates","cwLength","ccwCoordinates","ccwLength","push","drawInteraction","tracingFeature","raster","source","baseVector","format","url","drawVector","style","stroke","color","width","fill","previewLine","geometry","previewVector","features","map","layers","target","view","center","zoom","drawing","getFeatureOptions","hitTolerance","layerFilter","layer","on","event","hit","forEachFeatureAtPixel","pixel","coord","getCoordinateFromPixel","getClosestPoint","appendCoords","removeLastPoint","appendCoordinates","setCoordinates","previewCoords","snapInteraction","getSource","typeSelect","document","getElementById","addInteraction","value","type","onchange","removeInteraction"],"mappings":"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","file":"tracing.js","sourcesContent":["import Draw from '../src/ol/interaction/Draw.js';\r\nimport Feature from '../src/ol/Feature.js';\r\nimport Fill from '../src/ol/style/Fill.js';\r\nimport GeoJSON from '../src/ol/format/GeoJSON.js';\r\nimport LineString from '../src/ol/geom/LineString.js';\r\nimport Map from '../src/ol/Map.js';\r\nimport Snap from '../src/ol/interaction/Snap.js';\r\nimport Stroke from '../src/ol/style/Stroke.js';\r\nimport Style from '../src/ol/style/Style.js';\r\nimport View from '../src/ol/View.js';\r\nimport {OSM, Vector as VectorSource} from '../src/ol/source.js';\r\nimport {Tile as TileLayer, Vector as VectorLayer} from '../src/ol/layer.js';\r\n\r\n// math utilities\r\n\r\n// coordinates; will return the length of the [a, b] segment\r\nfunction length(a, b) {\r\n  return Math.sqrt(\r\n    (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1])\r\n  );\r\n}\r\n\r\n// coordinates; will return true if c is on the [a, b] segment\r\nfunction isOnSegment(c, a, b) {\r\n  const lengthAc = length(a, c);\r\n  const lengthAb = length(a, b);\r\n  const dot =\r\n    ((c[0] - a[0]) * (b[0] - a[0]) + (c[1] - a[1]) * (b[1] - a[1])) / lengthAb;\r\n  return Math.abs(lengthAc - dot) < 1e-6 && lengthAc < lengthAb;\r\n}\r\n\r\n// modulo for negative values, eg: mod(-1, 4) returns 3\r\nfunction mod(a, b) {\r\n  return ((a % b) + b) % b;\r\n}\r\n\r\n// returns a coordinates array which contains the segments of the feature's\r\n// outer ring between the start and end points\r\n// Note: this assumes the base feature is a single polygon\r\nfunction getPartialRingCoords(feature, startPoint, endPoint) {\r\n  let polygon = feature.getGeometry();\r\n  if (polygon.getType() === 'MultiPolygon') {\r\n    polygon = polygon.getPolygon(0);\r\n  }\r\n  const ringCoords = polygon.getLinearRing().getCoordinates();\r\n\r\n  let i,\r\n    pointA,\r\n    pointB,\r\n    startSegmentIndex = -1;\r\n  for (i = 0; i < ringCoords.length; i++) {\r\n    pointA = ringCoords[i];\r\n    pointB = ringCoords[mod(i + 1, ringCoords.length)];\r\n\r\n    // check if this is the start segment dot product\r\n    if (isOnSegment(startPoint, pointA, pointB)) {\r\n      startSegmentIndex = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  const cwCoordinates = [];\r\n  let cwLength = 0;\r\n  const ccwCoordinates = [];\r\n  let ccwLength = 0;\r\n\r\n  // build clockwise coordinates\r\n  for (i = 0; i < ringCoords.length; i++) {\r\n    pointA =\r\n      i === 0\r\n        ? startPoint\r\n        : ringCoords[mod(i + startSegmentIndex, ringCoords.length)];\r\n    pointB = ringCoords[mod(i + startSegmentIndex + 1, ringCoords.length)];\r\n    cwCoordinates.push(pointA);\r\n\r\n    if (isOnSegment(endPoint, pointA, pointB)) {\r\n      cwCoordinates.push(endPoint);\r\n      cwLength += length(pointA, endPoint);\r\n      break;\r\n    } else {\r\n      cwLength += length(pointA, pointB);\r\n    }\r\n  }\r\n\r\n  // build counter-clockwise coordinates\r\n  for (i = 0; i < ringCoords.length; i++) {\r\n    pointA = ringCoords[mod(startSegmentIndex - i, ringCoords.length)];\r\n    pointB =\r\n      i === 0\r\n        ? startPoint\r\n        : ringCoords[mod(startSegmentIndex - i + 1, ringCoords.length)];\r\n    ccwCoordinates.push(pointB);\r\n\r\n    if (isOnSegment(endPoint, pointA, pointB)) {\r\n      ccwCoordinates.push(endPoint);\r\n      ccwLength += length(endPoint, pointB);\r\n      break;\r\n    } else {\r\n      ccwLength += length(pointA, pointB);\r\n    }\r\n  }\r\n\r\n  // keep the shortest path\r\n  return ccwLength < cwLength ? ccwCoordinates : cwCoordinates;\r\n}\r\n\r\n// layers definition\r\n\r\nconst raster = new TileLayer({\r\n  source: new OSM(),\r\n});\r\n\r\n// features in this layer will be snapped to\r\nconst baseVector = new VectorLayer({\r\n  source: new VectorSource({\r\n    format: new GeoJSON(),\r\n    url:\r\n      \"https://ahocevar.com/geoserver/wfs?service=wfs&request=getfeature&typename=topp:states&cql_filter=STATE_NAME='Idaho'&outputformat=application/json\",\r\n  }),\r\n});\r\n\r\n// this is were the drawn features go\r\nconst drawVector = new VectorLayer({\r\n  source: new VectorSource(),\r\n  style: new Style({\r\n    stroke: new Stroke({\r\n      color: 'rgba(100, 255, 0, 1)',\r\n      width: 2,\r\n    }),\r\n    fill: new Fill({\r\n      color: 'rgba(100, 255, 0, 0.3)',\r\n    }),\r\n  }),\r\n});\r\n\r\n// this line only appears when we're tracing a feature outer ring\r\nconst previewLine = new Feature({\r\n  geometry: new LineString([]),\r\n});\r\nconst previewVector = new VectorLayer({\r\n  source: new VectorSource({\r\n    features: [previewLine],\r\n  }),\r\n  style: new Style({\r\n    stroke: new Stroke({\r\n      color: 'rgba(255, 0, 0, 1)',\r\n      width: 2,\r\n    }),\r\n  }),\r\n});\r\n\r\nconst map = new Map({\r\n  layers: [raster, baseVector, drawVector, previewVector],\r\n  target: 'map',\r\n  view: new View({\r\n    center: [-12986427, 5678422],\r\n    zoom: 5,\r\n  }),\r\n});\r\n\r\nlet drawInteraction, tracingFeature, startPoint, endPoint;\r\nlet drawing = false;\r\n\r\nconst getFeatureOptions = {\r\n  hitTolerance: 10,\r\n  layerFilter: (layer) => {\r\n    return layer === baseVector;\r\n  },\r\n};\r\n\r\n// the click event is used to start/end tracing around a feature\r\nmap.on('click', (event) => {\r\n  if (!drawing) {\r\n    return;\r\n  }\r\n\r\n  let hit = false;\r\n  map.forEachFeatureAtPixel(\r\n    event.pixel,\r\n    (feature) => {\r\n      if (tracingFeature && feature !== tracingFeature) {\r\n        return;\r\n      }\r\n\r\n      hit = true;\r\n      const coord = map.getCoordinateFromPixel(event.pixel);\r\n\r\n      // second click on the tracing feature: append the ring coordinates\r\n      if (feature === tracingFeature) {\r\n        endPoint = tracingFeature.getGeometry().getClosestPoint(coord);\r\n        const appendCoords = getPartialRingCoords(\r\n          tracingFeature,\r\n          startPoint,\r\n          endPoint\r\n        );\r\n        drawInteraction.removeLastPoint();\r\n        drawInteraction.appendCoordinates(appendCoords);\r\n        tracingFeature = null;\r\n      }\r\n\r\n      // start tracing on the feature ring\r\n      tracingFeature = feature;\r\n      startPoint = tracingFeature.getGeometry().getClosestPoint(coord);\r\n    },\r\n    getFeatureOptions\r\n  );\r\n\r\n  if (!hit) {\r\n    // clear current tracing feature & preview\r\n    previewLine.getGeometry().setCoordinates([]);\r\n    tracingFeature = null;\r\n  }\r\n});\r\n\r\n// the pointermove event is used to show a preview of the result of the tracing\r\nmap.on('pointermove', (event) => {\r\n  if (tracingFeature && drawing) {\r\n    let coord = null;\r\n    map.forEachFeatureAtPixel(\r\n      event.pixel,\r\n      (feature) => {\r\n        if (tracingFeature === feature) {\r\n          coord = map.getCoordinateFromPixel(event.pixel);\r\n        }\r\n      },\r\n      getFeatureOptions\r\n    );\r\n\r\n    let previewCoords = [];\r\n    if (coord) {\r\n      endPoint = tracingFeature.getGeometry().getClosestPoint(coord);\r\n      previewCoords = getPartialRingCoords(\r\n        tracingFeature,\r\n        startPoint,\r\n        endPoint\r\n      );\r\n    }\r\n    previewLine.getGeometry().setCoordinates(previewCoords);\r\n  }\r\n});\r\n\r\nconst snapInteraction = new Snap({\r\n  source: baseVector.getSource(),\r\n});\r\n\r\nconst typeSelect = document.getElementById('type');\r\n\r\nfunction addInteraction() {\r\n  const value = typeSelect.value;\r\n  if (value !== 'None') {\r\n    drawInteraction = new Draw({\r\n      source: drawVector.getSource(),\r\n      type: typeSelect.value,\r\n    });\r\n    drawInteraction.on('drawstart', () => {\r\n      drawing = true;\r\n    });\r\n    drawInteraction.on('drawend', () => {\r\n      drawing = false;\r\n      previewLine.getGeometry().setCoordinates([]);\r\n      tracingFeature = null;\r\n    });\r\n    map.addInteraction(drawInteraction);\r\n    map.addInteraction(snapInteraction);\r\n  }\r\n}\r\n\r\ntypeSelect.onchange = function () {\r\n  map.removeInteraction(drawInteraction);\r\n  map.removeInteraction(snapInteraction);\r\n  addInteraction();\r\n};\r\naddInteraction();\r\n"],"sourceRoot":""}